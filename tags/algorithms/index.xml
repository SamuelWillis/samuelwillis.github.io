<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithms on samuel willis</title><link>https://www.samuelwillis.dev/tags/algorithms/</link><description>Recent content in Algorithms on samuel willis</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 20 May 2021 21:00:50 -0600</lastBuildDate><atom:link href="https://www.samuelwillis.dev/tags/algorithms/index.xml" rel="self" type="application/rss+xml"/><item><title>Max Subarray in Elixir</title><link>https://www.samuelwillis.dev/posts/max-contiguous-sum-in-elixir/</link><pubDate>Thu, 20 May 2021 21:00:50 -0600</pubDate><guid>https://www.samuelwillis.dev/posts/max-contiguous-sum-in-elixir/</guid><description>The maximum subarray problem is defined as follows:
Given an array A find a nonempty, contiguous subarray of A whose values have the largest sum.
It&amp;rsquo;s an interesting little problem that benefits greatly from the use of a divide and conquer algorithm as the runtime goes from O(n^2) for the brute force method to O(nlog(n)) for the divide and conquer method.
Brute Force Method The brute force method is quite simple.</description></item><item><title>Insertion Sort in Elixir</title><link>https://www.samuelwillis.dev/posts/insertion-sort-in-elixir/</link><pubDate>Sat, 24 Apr 2021 12:59:20 -0600</pubDate><guid>https://www.samuelwillis.dev/posts/insertion-sort-in-elixir/</guid><description>Departing from Data Structures such as Queues and Stacks this post will cover the insertion sort algorithm in Elixir.
Insertion sort is one of the first sorting algorithms introduced in Computer Science as its quite simple.
Insertion sort is quite efficient on small data sets and it does the sort in place. Meaning it has O(1) (constant) memory space requirements. Unfortunately, this does not hold true in Elixir as recursion is used causing the space-complexity to be O(n) (linear).</description></item></channel></rss>