<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithms on samuel willis</title><link>https://www.samuelwillis.dev/tags/algorithms/</link><description>Recent content in Algorithms on samuel willis</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 01 Jun 2021 09:00:00 -0600</lastBuildDate><atom:link href="https://www.samuelwillis.dev/tags/algorithms/index.xml" rel="self" type="application/rss+xml"/><item><title>Heap Sort, Part 1</title><link>https://www.samuelwillis.dev/posts/heap-sort-part-1/</link><pubDate>Tue, 01 Jun 2021 09:00:00 -0600</pubDate><guid>https://www.samuelwillis.dev/posts/heap-sort-part-1/</guid><description>This is the first of a multi-part series on Heapsort.
While the Heapsort algorithm itself is a fairly simple algorithm, it poses some complexity when implemented in an immutable language that does not support index based arrays, such as Elixir.
This is because of the Heap data structure that Heapsort relies on. In imperative languages a Heap is trivially implemented through the use of an array and calculated indexes. Elixir does not provide us with this luxury, however.</description></item><item><title>Heap Sort, Part 2</title><link>https://www.samuelwillis.dev/posts/heap-sort-part-2/</link><pubDate>Tue, 01 Jun 2021 09:00:00 -0600</pubDate><guid>https://www.samuelwillis.dev/posts/heap-sort-part-2/</guid><description>Following from Part One in this heapsort series, this post will go over O(log(n)) insertions into the Heap.
Insertion will work using two traversals of the heap, the first finding the next available leaf and the second bubbling the new value up the heap to maintain the max heap property.
Due to Elixir&amp;rsquo;s immutability a new heap will need to be built at each step that updates the heap&amp;rsquo;s height, size, and children.</description></item><item><title>Max Subarray in Elixir</title><link>https://www.samuelwillis.dev/posts/max-contiguous-sum-in-elixir/</link><pubDate>Thu, 20 May 2021 21:00:50 -0600</pubDate><guid>https://www.samuelwillis.dev/posts/max-contiguous-sum-in-elixir/</guid><description>The maximum subarray problem is defined as follows:
Given an array A find a nonempty, contiguous subarray of A whose values have the largest sum.
It&amp;rsquo;s an interesting little problem that benefits greatly from the use of a divide and conquer algorithm as the runtime goes from O(n^2) for the brute force method to O(nlog(n)) for the divide and conquer method.
Brute Force Method The brute force method is quite simple.</description></item><item><title>Insertion Sort in Elixir</title><link>https://www.samuelwillis.dev/posts/insertion-sort-in-elixir/</link><pubDate>Sat, 24 Apr 2021 12:59:20 -0600</pubDate><guid>https://www.samuelwillis.dev/posts/insertion-sort-in-elixir/</guid><description>Departing from Data Structures such as Queues and Stacks this post will cover the insertion sort algorithm in Elixir.
Insertion sort is one of the first sorting algorithms introduced in Computer Science as its quite simple.
Insertion sort is quite efficient on small data sets and it does the sort in place. Meaning it has O(1) (constant) memory space requirements. Unfortunately, this does not hold true in Elixir as recursion is used causing the space-complexity to be O(n) (linear).</description></item></channel></rss>