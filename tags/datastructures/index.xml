<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>DataStructures on samuel willis</title><link>https://www.samuelwillis.dev/tags/datastructures/</link><description>Recent content in DataStructures on samuel willis</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 01 Jun 2021 09:00:00 -0600</lastBuildDate><atom:link href="https://www.samuelwillis.dev/tags/datastructures/index.xml" rel="self" type="application/rss+xml"/><item><title>Heap Sort, Part 1</title><link>https://www.samuelwillis.dev/posts/heap-sort-part-1/</link><pubDate>Tue, 01 Jun 2021 09:00:00 -0600</pubDate><guid>https://www.samuelwillis.dev/posts/heap-sort-part-1/</guid><description>This is the first of a multi-part series on Heapsort.
While the Heapsort algorithm itself is a fairly simple algorithm, it poses some complexity when implemented in an immutable language that does not support index based arrays, such as Elixir.
This is because of the Heap data structure that Heapsort relies on. In imperative languages a Heap is trivially implemented through the use of an array and calculated indexes. Elixir does not provide us with this luxury, however.</description></item><item><title>Heap Sort, Part 2</title><link>https://www.samuelwillis.dev/posts/heap-sort-part-2/</link><pubDate>Tue, 01 Jun 2021 09:00:00 -0600</pubDate><guid>https://www.samuelwillis.dev/posts/heap-sort-part-2/</guid><description>Following from Part One in this heapsort series, this post will go over O(log(n)) insertions into the Heap.
Insertion will work using two traversals of the heap, the first finding the next available leaf and the second bubbling the new value up the heap to maintain the max heap property.
Due to Elixir&amp;rsquo;s immutability a new heap will need to be built at each step that updates the heap&amp;rsquo;s height, size, and children.</description></item><item><title>Queues in Elixir</title><link>https://www.samuelwillis.dev/posts/queues-in-elixir/</link><pubDate>Tue, 13 Apr 2021 18:36:07 -0600</pubDate><guid>https://www.samuelwillis.dev/posts/queues-in-elixir/</guid><description>Continuing on from my previous Stacks in Elixir post today I will cover implementing Queues in Elixir.
Queues operate on a First In First out (FIFO) policy, meaning the first item placed onto the queue is the first to be removed.
These are again essentially sugar for lists but there&amp;rsquo;s a few gotchas to get around when implementing them in Elixir. The main being that appending to lists can be an expensive operation in Elixir.</description></item><item><title>Stacks in Elixir</title><link>https://www.samuelwillis.dev/posts/stacks-in-elixir/</link><pubDate>Sun, 11 Apr 2021 15:12:45 -0600</pubDate><guid>https://www.samuelwillis.dev/posts/stacks-in-elixir/</guid><description>Stacks are one of the most basic data structures in Computer Science. Nonetheless, they are quite useful and used often.
They operate under the Last In First Out (LIFO) policy, meaning the last object placed onto the stack is the first one to be removed from it.
In Elixir they are essentially syntactical sugar for Lists but implementing them was a nice way to get acquainted with Structs and basic pattern matching.</description></item></channel></rss>