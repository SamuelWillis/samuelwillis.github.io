<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Functional on samuel willis</title><link>https://www.samuelwillis.dev/tags/functional/</link><description>Recent content in Functional on samuel willis</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 01 Jul 2021 09:00:00 -0600</lastBuildDate><atom:link href="https://www.samuelwillis.dev/tags/functional/index.xml" rel="self" type="application/rss+xml"/><item><title>Heap Sort, Part 2</title><link>https://www.samuelwillis.dev/posts/heap-sort-part-2/</link><pubDate>Thu, 01 Jul 2021 09:00:00 -0600</pubDate><guid>https://www.samuelwillis.dev/posts/heap-sort-part-2/</guid><description>Following from Part One in this heapsort series, this post will go over O(log(n)) insertions into the Heap.
Insertion will work using two traversals of the heap, the first finding the next available leaf and the second bubbling the new value up the heap to maintain the max heap property.
Due to Elixir&amp;rsquo;s immutability a new heap will need to be built at each step that updates the heap&amp;rsquo;s height, size, and children.</description></item><item><title>Heap Sort, Part 1</title><link>https://www.samuelwillis.dev/posts/heap-sort-part-1/</link><pubDate>Tue, 01 Jun 2021 09:00:00 -0600</pubDate><guid>https://www.samuelwillis.dev/posts/heap-sort-part-1/</guid><description>This is the first of a multi-part series on Heapsort.
While the Heapsort algorithm itself is a fairly simple algorithm, it poses some complexity when implemented in an immutable language that does not support index based arrays, such as Elixir.
This is because of the Heap data structure that Heapsort relies on. In imperative languages a Heap is trivially implemented through the use of an array and calculated indexes. Elixir does not provide us with this luxury, however.</description></item></channel></rss>