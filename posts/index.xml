<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on samuel willis</title><link>https://www.samuelwillis.dev/posts/</link><description>Recent content in Posts on samuel willis</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 01 Jul 2021 09:00:00 -0600</lastBuildDate><atom:link href="https://www.samuelwillis.dev/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Heap Sort, Part 2</title><link>https://www.samuelwillis.dev/posts/heap-sort-part-2/</link><pubDate>Thu, 01 Jul 2021 09:00:00 -0600</pubDate><guid>https://www.samuelwillis.dev/posts/heap-sort-part-2/</guid><description>Following from Part One in this heapsort series, this post will go over O(log(n)) insertions into the Heap.
Insertion will work using two traversals of the heap, the first finding the next available leaf and the second bubbling the new value up the heap to maintain the max heap property.
Due to Elixir&amp;rsquo;s immutability a new heap will need to be built at each step that updates the heap&amp;rsquo;s height, size, and children.</description><content type="html"><![CDATA[<p>Following from <a href="https://www.samuelwillis.dev/posts/heap-sort-part-1/">Part One</a> in this heapsort
series, this post will go over <code>O(log(n))</code> insertions into the Heap.</p>
<p>Insertion will work using two traversals of the heap, the first finding the
next available leaf and the second bubbling the new value up the heap to
maintain the max heap property.</p>
<p>Due to Elixir&rsquo;s immutability a new heap will need to be built at each step that
updates the heap&rsquo;s height, size, and children.</p>
<p>Since there is two traversals, I&rsquo;ll split the implementation up into two
portions.
The first traversal down to the next available leaf and then the second
traversal to bubble the new value to its correct spot in the heap.</p>
<h2 id="finding-the-leaf">Finding the leaf</h2>
<p>Finding the next available leaf was probably one of the trickier parts of the
insertion.
In the end, it hinges on the array definition of a heap and the index of a
leaf&rsquo;s parent in the array.</p>
<p>To start, we will do the 3 base clauses:</p>
<ol>
<li>Insertion into empty heap =&gt; set the heap&rsquo;s value.</li>
<li>Insertion into a heap that is a leaf =&gt; add a left child to the parent heap
that has the value being inserted.</li>
<li>Insertion into a heap that does not have a right child =&gt; add a right child
to the parent heap that has the value being inserted.</li>
</ol>
<p>These clauses are the simple cases and cover &ldquo;filling&rdquo; a heap.
To implement them a custom guard will be used to determine if a heap is a leaf
or not.
A heap is considered a leaf if it has no children.</p>
<p>In each clause, a new heap will be created that includes the new value at the
appropriate place and the new size of the heap.</p>
<p>Notice only the clauses that add a value to an empty heap or the left child will
increase the heap&rsquo;s height, however.
This is because adding a right child to a heap does not increase the heap&rsquo;s
height.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-elixir" data-lang="elixir">  <span class="n">defguard</span> <span class="n">is_empty</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span> <span class="ow">when</span> <span class="n">heap</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span>

  <span class="n">defguard</span> <span class="n">is_leaf</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span> <span class="ow">when</span> <span class="n">is_nil</span><span class="p">(</span><span class="n">heap</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_nil</span><span class="p">(</span><span class="n">heap</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

  <span class="na">@doc</span> <span class="sh">&#34;&#34;&#34;
</span><span class="sh">  Push the new value into the heap.
</span><span class="sh">  &#34;&#34;&#34;</span>
  <span class="na">@spec</span> <span class="n">push</span><span class="p">(</span><span class="n">t</span><span class="p">(),</span> <span class="n">integer</span><span class="p">())</span> <span class="o">::</span> <span class="n">t</span><span class="p">()</span>
  <span class="kd">def</span> <span class="n">push</span><span class="p">(</span><span class="err">%</span><span class="n">__MODULE__</span><span class="p">{}</span> <span class="o">=</span> <span class="n">heap</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">when</span> <span class="n">is_empty</span><span class="p">(</span><span class="n">heap</span><span class="p">),</span>
    <span class="ss">do</span><span class="p">:</span> <span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span><span class="ss">value</span><span class="p">:</span> <span class="n">value</span><span class="p">,</span> <span class="ss">height</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="ss">size</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>

  <span class="kd">def</span> <span class="n">push</span><span class="p">(</span><span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span><span class="ss">height</span><span class="p">:</span> <span class="n">height</span><span class="p">,</span> <span class="ss">size</span><span class="p">:</span> <span class="n">size</span><span class="p">}</span> <span class="o">=</span> <span class="n">heap</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="ow">when</span> <span class="n">is_leaf</span><span class="p">(</span><span class="n">heap</span><span class="p">),</span>
    <span class="ss">do</span><span class="p">:</span>
      <span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span>
        <span class="n">heap</span>
        <span class="o">|</span> <span class="ss">height</span><span class="p">:</span> <span class="n">height</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
          <span class="ss">size</span><span class="p">:</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
          <span class="c1"># Push the value onto an empty heap</span>
          <span class="ss">left</span><span class="p">:</span> <span class="n">push</span><span class="p">(</span><span class="err">%</span><span class="n">__MODULE__</span><span class="p">{},</span> <span class="n">value</span><span class="p">)</span>
      <span class="p">}</span>

  <span class="kd">def</span> <span class="n">push</span><span class="p">(</span><span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span><span class="ss">size</span><span class="p">:</span> <span class="n">size</span><span class="p">,</span> <span class="ss">left</span><span class="p">:</span> <span class="n">left</span><span class="p">,</span> <span class="ss">right</span><span class="p">:</span> <span class="n">right</span><span class="p">}</span> <span class="o">=</span> <span class="n">heap</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="ow">when</span> <span class="n">is_nil</span><span class="p">(</span><span class="n">right</span><span class="p">),</span>
    <span class="ss">do</span><span class="p">:</span>
      <span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span>
        <span class="n">heap</span>
        <span class="o">|</span> <span class="ss">size</span><span class="p">:</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
          <span class="c1"># push the value onto a empty heap</span>
          <span class="ss">right</span><span class="p">:</span> <span class="n">push</span><span class="p">(</span><span class="err">%</span><span class="n">__MODULE__</span><span class="p">{},</span> <span class="n">value</span><span class="p">)</span>
      <span class="p">}</span>
</code></pre></div><p>The remaining two clauses need to determine if the next available spot is in the
left or right child heaps.</p>
<p>The trick to this is finding the next available leaf&rsquo;s parent index if it were
an array implementation.</p>
<p>Given a the size of the heap with the new value inserted, the node will be in
the left subtree if the parent index is divisible by 2, due to the array
index definitions <code>left_child_index(i): 2*i</code> and <code>parent_index(i): floor(i/2)</code>.</p>
<p>Similarily, the new node will be in the right subtree if the parent index is not
divisible by 2, again from the array index definitions <code>right(i): 2*i + 1</code> and
<code>parent(i): floor(i/2)</code>.</p>
<p>So the last two clauses will build a new heap with the new value inserted into
the appropriate subtree.
The new heap will have the updated size, as well as a new height.
The height is determined to be the max height of the heap&rsquo;s subtrees plus 1.</p>
<p>Using guards to makes this really expresive:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-elixir" data-lang="elixir">  <span class="n">defguard</span> <span class="n">is_next_leaf_in_left_subtree</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="ow">when</span> <span class="n">size</span> <span class="o">|&gt;</span> <span class="n">div</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="n">rem</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
  <span class="n">defguard</span> <span class="n">is_next_leaf_in_right_subtree</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="ow">when</span> <span class="n">size</span> <span class="o">|&gt;</span> <span class="n">div</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="n">rem</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

  <span class="na">@spec</span> <span class="n">push</span><span class="p">(</span><span class="n">t</span><span class="p">(),</span> <span class="n">integer</span><span class="p">())</span> <span class="o">::</span> <span class="n">t</span><span class="p">()</span>
  <span class="kd">def</span> <span class="n">push</span><span class="p">(</span><span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span><span class="ss">left</span><span class="p">:</span> <span class="n">left</span><span class="p">,</span> <span class="ss">right</span><span class="p">:</span> <span class="n">right</span><span class="p">,</span> <span class="ss">size</span><span class="p">:</span> <span class="n">size</span><span class="p">}</span> <span class="o">=</span> <span class="n">heap</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
      <span class="ow">when</span> <span class="n">is_next_leaf_in_left_subtree</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">new_left</span> <span class="o">=</span> <span class="n">push</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span>
      <span class="n">heap</span>
      <span class="o">|</span> <span class="ss">height</span><span class="p">:</span> <span class="n">max</span><span class="p">(</span><span class="n">new_left</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">height</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="ss">size</span><span class="p">:</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="ss">left</span><span class="p">:</span> <span class="n">new_left</span><span class="p">,</span>
        <span class="ss">right</span><span class="p">:</span> <span class="n">right</span>
    <span class="p">}</span>
  <span class="k">end</span>

  <span class="kd">def</span> <span class="n">push</span><span class="p">(</span><span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span><span class="ss">left</span><span class="p">:</span> <span class="n">left</span><span class="p">,</span> <span class="ss">right</span><span class="p">:</span> <span class="n">right</span><span class="p">,</span> <span class="ss">size</span><span class="p">:</span> <span class="n">size</span><span class="p">}</span> <span class="o">=</span> <span class="n">heap</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
      <span class="ow">when</span> <span class="n">is_next_leaf_in_right_subtree</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">new_right</span> <span class="o">=</span> <span class="n">push</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span>
      <span class="n">heap</span>
      <span class="o">|</span> <span class="ss">height</span><span class="p">:</span> <span class="n">max</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">new_right</span><span class="o">.</span><span class="n">height</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="ss">size</span><span class="p">:</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="ss">left</span><span class="p">:</span> <span class="n">left</span><span class="p">,</span>
        <span class="ss">right</span><span class="p">:</span> <span class="n">new_right</span>
    <span class="p">}</span>
  <span class="k">end</span>
</code></pre></div><p>Now that we&rsquo;ve handled pushing a new value onto the heap at the correct place,
we need to ensure that the max-heap property is maintained.</p>
<p>To do this we need to bubble up the inserted value to the correct position in
the heap it was inserted into.</p>
<h2 id="bubble-up-routine">Bubble up routine</h2>
<p>To bubble the new value up to its proper position in the heap a bubble up
routine will be needed.</p>
<p>The routine will accept a Heap struct and check the root value against the
children values, swapping them if needed to maintain the mx heap property.</p>
<p>There are 3 cases:</p>
<ol>
<li>The right value is larger than the left value  and root value</li>
<li>The left value is larger than the right value and root value</li>
<li>The root is the largest value</li>
</ol>
<p>In case 1, the root value is swapped with the right value, in case 2 the root
value is swapped with the left value, and in case 3 nothing is swapped and the
original heap is returned.</p>
<p>Implementing this can be written very clearly using function clauses, pattern
matching, and guards in Elixir.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-elixir" data-lang="elixir">  <span class="na">@spec</span> <span class="n">bubble_up</span><span class="p">(</span><span class="n">heap</span> <span class="o">::</span> <span class="n">t</span><span class="p">())</span> <span class="o">::</span> <span class="n">t</span><span class="p">()</span>
  <span class="kd">def</span> <span class="n">bubble_up</span><span class="p">(</span><span class="n">__MODULE__</span><span class="p">{</span><span class="ss">left</span><span class="p">:</span> <span class="n">__MODULE__</span><span class="p">{},</span> <span class="ss">right</span><span class="p">:</span> <span class="n">__MODULE__</span><span class="p">{}}</span> <span class="o">=</span> <span class="n">heap</span><span class="p">)</span>
      <span class="ow">when</span> <span class="n">heap</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">value</span> <span class="ow">and</span>
             <span class="n">heap</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
      <span class="ss">do</span><span class="p">:</span> <span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span>
        <span class="n">heap</span>
        <span class="o">|</span> <span class="ss">value</span><span class="p">:</span> <span class="n">heap</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
          <span class="ss">right</span><span class="p">:</span> <span class="n">__MODULE__</span><span class="p">{</span><span class="n">heap</span><span class="o">.</span><span class="n">right</span> <span class="o">|</span> <span class="ss">value</span><span class="p">:</span> <span class="n">heap</span><span class="o">.</span><span class="n">value</span><span class="p">}</span>
      <span class="p">}</span>

  <span class="kd">def</span> <span class="n">bubble_up</span><span class="p">(</span><span class="n">__MODULE__</span><span class="p">{</span><span class="ss">left</span><span class="p">:</span> <span class="n">__MODULE__</span><span class="p">{}}</span> <span class="o">=</span> <span class="n">heap</span><span class="p">)</span>
      <span class="ow">when</span> <span class="n">heap</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
      <span class="ss">do</span><span class="p">:</span> <span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span>
        <span class="n">heap</span>
        <span class="o">|</span> <span class="ss">value</span><span class="p">:</span> <span class="n">heap</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
          <span class="ss">left</span><span class="p">:</span> <span class="n">__MODULE__</span><span class="p">{</span><span class="n">heap</span><span class="o">.</span><span class="n">left</span> <span class="o">|</span> <span class="ss">value</span><span class="p">:</span> <span class="n">heap</span><span class="o">.</span><span class="n">value</span><span class="p">}</span>
      <span class="p">}</span>

  <span class="kd">def</span> <span class="n">bubble_up</span><span class="p">(</span><span class="err">%</span><span class="n">__MODULE__</span><span class="p">{}</span> <span class="o">=</span> <span class="n">heap</span><span class="p">),</span> <span class="ss">do</span><span class="p">:</span> <span class="n">heap</span>
</code></pre></div><p>Now the routine needs to be used by the <code>push</code> function.</p>
<h3 id="putting-it-all-together">Putting it all together</h3>
<p>Putting all the above together the resulting code is quite lengthy but still
expressive in its intent.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">ElixirImpl.DataStructure.Heap</span> <span class="k">do</span>
  <span class="n">defguard</span> <span class="n">is_empty</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span> <span class="ow">when</span> <span class="n">heap</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span>

  <span class="n">defguard</span> <span class="n">is_leaf</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span> <span class="ow">when</span> <span class="n">is_nil</span><span class="p">(</span><span class="n">heap</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_nil</span><span class="p">(</span><span class="n">heap</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

  <span class="n">defguard</span> <span class="n">is_next_leaf_in_left_subtree</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="ow">when</span> <span class="n">size</span> <span class="o">|&gt;</span> <span class="n">div</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="n">rem</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
  <span class="n">defguard</span> <span class="n">is_next_leaf_in_right_subtree</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="ow">when</span> <span class="n">size</span> <span class="o">|&gt;</span> <span class="n">div</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="n">rem</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

  <span class="na">@doc</span> <span class="sh">&#34;&#34;&#34;
</span><span class="sh">  Push the new value into the heap.
</span><span class="sh">  &#34;&#34;&#34;</span>
  <span class="na">@spec</span> <span class="n">push</span><span class="p">(</span><span class="n">t</span><span class="p">(),</span> <span class="n">integer</span><span class="p">())</span> <span class="o">::</span> <span class="n">t</span><span class="p">()</span>
  <span class="kd">def</span> <span class="n">push</span><span class="p">(</span><span class="err">%</span><span class="n">__MODULE__</span><span class="p">{}</span> <span class="o">=</span> <span class="n">heap</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">when</span> <span class="n">is_empty</span><span class="p">(</span><span class="n">heap</span><span class="p">),</span>
    <span class="ss">do</span><span class="p">:</span> <span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span><span class="ss">value</span><span class="p">:</span> <span class="n">value</span><span class="p">,</span> <span class="ss">height</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="ss">size</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>

  <span class="kd">def</span> <span class="n">push</span><span class="p">(</span><span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span><span class="ss">height</span><span class="p">:</span> <span class="n">height</span><span class="p">,</span> <span class="ss">size</span><span class="p">:</span> <span class="n">size</span><span class="p">}</span> <span class="o">=</span> <span class="n">heap</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="ow">when</span> <span class="n">is_leaf</span><span class="p">(</span><span class="n">heap</span><span class="p">),</span>
    <span class="ss">do</span><span class="p">:</span>
      <span class="n">bubble_up</span><span class="p">(</span><span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span>
        <span class="n">heap</span>
        <span class="o">|</span> <span class="ss">height</span><span class="p">:</span> <span class="n">height</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
          <span class="ss">size</span><span class="p">:</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
          <span class="ss">left</span><span class="p">:</span> <span class="n">push</span><span class="p">(</span><span class="err">%</span><span class="n">__MODULE__</span><span class="p">{},</span> <span class="n">value</span><span class="p">)</span>
      <span class="p">})</span>

  <span class="kd">def</span> <span class="n">push</span><span class="p">(</span><span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span><span class="ss">size</span><span class="p">:</span> <span class="n">size</span><span class="p">,</span> <span class="ss">left</span><span class="p">:</span> <span class="n">left</span><span class="p">,</span> <span class="ss">right</span><span class="p">:</span> <span class="n">right</span><span class="p">}</span> <span class="o">=</span> <span class="n">heap</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="ow">when</span> <span class="n">is_nil</span><span class="p">(</span><span class="n">right</span><span class="p">),</span>
    <span class="ss">do</span><span class="p">:</span>
      <span class="n">bubble_up</span><span class="p">(</span><span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span>
        <span class="n">heap</span>
        <span class="o">|</span> <span class="ss">size</span><span class="p">:</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
          <span class="ss">right</span><span class="p">:</span> <span class="n">push</span><span class="p">(</span><span class="err">%</span><span class="n">__MODULE__</span><span class="p">{},</span> <span class="n">value</span><span class="p">)</span>
      <span class="p">})</span>

  <span class="kd">def</span> <span class="n">push</span><span class="p">(</span><span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span><span class="ss">left</span><span class="p">:</span> <span class="n">left</span><span class="p">,</span> <span class="ss">right</span><span class="p">:</span> <span class="n">right</span><span class="p">,</span> <span class="ss">size</span><span class="p">:</span> <span class="n">size</span><span class="p">}</span> <span class="o">=</span> <span class="n">heap</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
      <span class="ow">when</span> <span class="n">is_next_leaf_in_left_subtree</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">new_left</span> <span class="o">=</span> <span class="n">push</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="n">bubble_up</span><span class="p">(</span><span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span>
      <span class="n">heap</span>
      <span class="o">|</span> <span class="ss">height</span><span class="p">:</span> <span class="n">max</span><span class="p">(</span><span class="n">new_left</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">height</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="ss">size</span><span class="p">:</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="ss">left</span><span class="p">:</span> <span class="n">new_left</span><span class="p">,</span>
        <span class="ss">right</span><span class="p">:</span> <span class="n">right</span>
    <span class="p">})</span>
  <span class="k">end</span>

  <span class="kd">def</span> <span class="n">push</span><span class="p">(</span><span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span><span class="ss">left</span><span class="p">:</span> <span class="n">left</span><span class="p">,</span> <span class="ss">right</span><span class="p">:</span> <span class="n">right</span><span class="p">,</span> <span class="ss">size</span><span class="p">:</span> <span class="n">size</span><span class="p">}</span> <span class="o">=</span> <span class="n">heap</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
      <span class="ow">when</span> <span class="n">is_next_leaf_in_right_subtree</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">new_right</span> <span class="o">=</span> <span class="n">push</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="n">bubble_up</span><span class="p">(</span><span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span>
      <span class="n">heap</span>
      <span class="o">|</span> <span class="ss">height</span><span class="p">:</span> <span class="n">max</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">new_right</span><span class="o">.</span><span class="n">height</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="ss">size</span><span class="p">:</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="ss">left</span><span class="p">:</span> <span class="n">left</span><span class="p">,</span>
        <span class="ss">right</span><span class="p">:</span> <span class="n">new_right</span>
    <span class="p">})</span>
  <span class="k">end</span>

  <span class="na">@spec</span> <span class="n">bubble_up</span><span class="p">(</span><span class="n">heap</span> <span class="o">::</span> <span class="n">t</span><span class="p">())</span> <span class="o">::</span> <span class="n">t</span><span class="p">()</span>
  <span class="kd">def</span> <span class="n">bubble_up</span><span class="p">(</span><span class="n">__MODULE__</span><span class="p">{</span><span class="ss">left</span><span class="p">:</span> <span class="n">__MODULE__</span><span class="p">{},</span> <span class="ss">right</span><span class="p">:</span> <span class="n">__MODULE__</span><span class="p">{}}</span> <span class="o">=</span> <span class="n">heap</span><span class="p">)</span>
      <span class="ow">when</span> <span class="n">heap</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">value</span> <span class="ow">and</span>
             <span class="n">heap</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
      <span class="ss">do</span><span class="p">:</span> <span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span>
        <span class="n">heap</span>
        <span class="o">|</span> <span class="ss">value</span><span class="p">:</span> <span class="n">heap</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
          <span class="ss">right</span><span class="p">:</span> <span class="n">__MODULE__</span><span class="p">{</span><span class="n">heap</span><span class="o">.</span><span class="n">right</span> <span class="o">|</span> <span class="ss">value</span><span class="p">:</span> <span class="n">heap</span><span class="o">.</span><span class="n">value</span><span class="p">}</span>
      <span class="p">}</span>

  <span class="kd">def</span> <span class="n">bubble_up</span><span class="p">(</span><span class="n">__MODULE__</span><span class="p">{</span><span class="ss">left</span><span class="p">:</span> <span class="n">__MODULE__</span><span class="p">{}}</span> <span class="o">=</span> <span class="n">heap</span><span class="p">)</span>
      <span class="ow">when</span> <span class="n">heap</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
      <span class="ss">do</span><span class="p">:</span> <span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span>
        <span class="n">heap</span>
        <span class="o">|</span> <span class="ss">value</span><span class="p">:</span> <span class="n">heap</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
          <span class="ss">left</span><span class="p">:</span> <span class="n">__MODULE__</span><span class="p">{</span><span class="n">heap</span><span class="o">.</span><span class="n">left</span> <span class="o">|</span> <span class="ss">value</span><span class="p">:</span> <span class="n">heap</span><span class="o">.</span><span class="n">value</span><span class="p">}</span>
      <span class="p">}</span>

  <span class="kd">def</span> <span class="n">bubble_up</span><span class="p">(</span><span class="err">%</span><span class="n">__MODULE__</span><span class="p">{}</span> <span class="o">=</span> <span class="n">heap</span><span class="p">),</span> <span class="ss">do</span><span class="p">:</span> <span class="n">heap</span>
<span class="k">end</span>
</code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>Although complicated, Elixir really helped with writing clear and intention
revealing code through guards and pattern matching.</p>
<p>I can&rsquo;t help but attribute this to the lack of <code>if</code> statements needed inside of
functions, but that&rsquo;s a discussion for another day.</p>
<p>A downside to this code is, although it&rsquo;s intention revealing, it&rsquo;s likely less
perfomant than an iterative implementation.
There&rsquo;s a lot of memory use behind the creation of new heaps each time we need
to update a value.</p>
<p>Elixir&rsquo;s immutability is a hinderance here but it is maybe offset somewhat by
garbage collection being able to dispose of the intermediary heaps as soon as
they&rsquo;re no longer in use.
I do not fully understand garbage collection in Elixir yet, but I believe this
is the case.</p>
<p>If you&rsquo;re interested in the full implementation of a Heap, <a href="https://github.com/SamuelWillis/algorithms/blob/main/elixir/lib/data_structures/heap.ex">see it
here</a>.</p>
<p>If you have comments, improvements, or corrections please feel free to leave an
<a href="https://github.com/SamuelWillis/algorithms/issues">issue in Github</a>.</p>
]]></content></item><item><title>Heap Sort, Part 1</title><link>https://www.samuelwillis.dev/posts/heap-sort-part-1/</link><pubDate>Tue, 01 Jun 2021 09:00:00 -0600</pubDate><guid>https://www.samuelwillis.dev/posts/heap-sort-part-1/</guid><description>This is the first of a multi-part series on Heapsort.
While the Heapsort algorithm itself is a fairly simple algorithm, it poses some complexity when implemented in an immutable language that does not support index based arrays, such as Elixir.
This is because of the Heap data structure that Heapsort relies on. In imperative languages a Heap is trivially implemented through the use of an array and calculated indexes. Elixir does not provide us with this luxury, however.</description><content type="html"><![CDATA[<p>This is the first of a multi-part series on Heapsort.</p>
<p>While the Heapsort algorithm itself is a fairly simple algorithm, it poses some
complexity when implemented in an immutable language that does not support index
based arrays, such as Elixir.</p>
<p>This is because of the Heap data structure that Heapsort relies on.
In imperative languages a Heap is trivially implemented through the use of an
array and calculated indexes. Elixir does not provide us with this luxury,
however.</p>
<p>In this series of posts I will showcase an implementation of Heaps using
pointers that maintains the <code>O(log(n))</code> insertion and removal of elements.
It will then be used to implement Heapsort.</p>
<p>The series will be broken up into 4 parts:</p>
<ol>
<li>Introduction to Heap Data Structure (this post)</li>
<li><code>O(log(n))</code> insertions with Heap</li>
<li><code>O(log(n))</code> removals with Heap</li>
<li>Heapsort implementation using the Heap</li>
</ol>
<h2 id="citations">Citations</h2>
<p>Before we proceed, I would like to give cite some resources that I used to write
this code.</p>
<p>Without these resources, I would probably still be scratching my head in
confusion and I found them to be indispensable while working this Heapsort
implementation.
Especially for the insertion and removal procedures in <code>O(log(n))</code> time.</p>
<p>Each resource is also cited in the final implementation&rsquo;s source code.</p>
<ol>
<li><a href="https://www.cpp.edu/~ftang/courses/CS241/notes/Building_Heaps_With_Pointers.pdf">Paul Picazo&rsquo;s paper on
Peaps</a>
<ul>
<li>Provided a much simplified algorithm to find the next place to insert a new
element</li>
</ul>
</li>
<li>Vladimir Kostyukov&rsquo;s <a href="https://kostyukov.net/posts/designing-a-pfds/">Scala Heap Blog Post</a>
<ul>
<li>A great write up on transforming imperative/RAM based algorithms into
functional ones.</li>
<li>Focussed on implementing a Heap in Scala</li>
</ul>
</li>
<li>Vladimir Kostyukov&rsquo;s <a href="http://arxiv.org/pdf/1312.4666v1.pdf">paper</a>
<ul>
<li>A more complete version of their blog post</li>
<li>Includes efficient algorithm for element removal</li>
</ul>
</li>
<li>Vladimir Kostyukov&rsquo;s <a href="https://github.com/vkostyukov/scalacaster/blob/master/src/heap/StandardHeap.scala">source code</a>
<ul>
<li>Scala source code for their own implementation.</li>
</ul>
</li>
</ol>
<p>Thank you Paul and Vladimir for such great source material.</p>
<h2 id="heap-sort">Heap Sort</h2>
<p>Heap sort uses the properties of Heaps to sort an array.</p>
<p>It works as follows:</p>
<ol>
<li>Place all elements of array into a heap</li>
<li>Repeatedly remove the root element of the heap and insert it into the array</li>
</ol>
<p>The <em>Heap Property</em> ensures that the resulting array is in sorted order.</p>
<h2 id="implementation">Implementation</h2>
<p>To start the implementation of heap sort, we will need an efficient heap.
This will be represented by a module with schema in Elixir.</p>
<h3 id="the-heap-data-structure">The heap data structure</h3>
<p>With the house-keeping out of the way let&rsquo;s introduce the heap data structure.</p>
<p>There are two properties that a Heap has:</p>
<ol>
<li><strong>Shape Property:</strong> Heaps are <em>complete binary trees</em>. Meaning all levels, except possibly the
last one, are fully filled and all nodes are filled from left to right.</li>
<li><strong>Heap Property:</strong> The key stored in each node is either greater than or equal to (<em>max-heap</em>) or less than or
equal to (<em>min-heap</em>) the keys in the node&rsquo;s children</li>
</ol>
<p>Some other useful properties are:</p>
<ol>
<li>The left child index of a node in an array representation of a heap is given
by <code>2*i</code> where <code>i</code> is the index of the node in the array.</li>
<li>The right child index of a node in an array representation of a heap is given
by <code>2*i + 1</code> where <code>i</code> is the index of the node in the array.</li>
<li>The maximum number of nodes in a complete binary tree is <code>2^(h) - 1</code> where
<code>h</code> is the height of the tree. A tree of only a root node has a height of <code>0</code>.</li>
</ol>
<h3 id="code">Code</h3>
<p>This implementation of a heap will be recursive.
Meaning each node in the heap will itself be a heap.</p>
<p>In the heap we will want to track several things:</p>
<ol>
<li>The <strong>value</strong> of the heap</li>
<li>The <strong>size</strong> of the heap, ie: the number of nodes in the heap</li>
<li>The <strong>height</strong> of the heap, ie: the largest number of edges from a leaf to
the node.</li>
<li>The <strong>left child</strong> of the heap</li>
<li>The <strong>right child</strong> of the heap</li>
</ol>
<p>To start this implementation, lets configure a struct that will represent a
<code>Heap</code>.</p>
<p>The struct will define the supported fields, with some sensible defaults for
empty heaps, as well as a <em>typespec</em>.</p>
<p>In an empty Heap, the value and children will be <code>nil</code> and the <code>height</code> and
<code>size</code> will be <code>0</code>.</p>
<p>The typespec for the Heap will type the <code>value</code> as an integer for simplicities'
sake.</p>
<p>We will also add a simple function called <code>new</code> that will return a new <code>Heap</code>
for us.
While not necessary, it&rsquo;s a nice to have.</p>
<p>With this in mind we get:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">ElixirImpl.DataStructure.Heap</span> <span class="k">do</span>
  <span class="na">@moduledoc</span> <span class="sh">&#34;&#34;&#34;
</span><span class="sh">  A functional implementation of the heap data structure.
</span><span class="sh">  &#34;&#34;&#34;</span>

  <span class="kd">defstruct</span>
  <span class="ss">value</span><span class="p">:</span> <span class="no">nil</span><span class="p">,</span>
  <span class="ss">left</span><span class="p">:</span> <span class="no">nil</span><span class="p">,</span>
  <span class="ss">size</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="ss">height</span><span class="p">:</span> <span class="mi">0</span>

  <span class="na">@type</span> <span class="n">t</span> <span class="o">::</span> <span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span>
          <span class="ss">value</span><span class="p">:</span> <span class="n">integer</span><span class="p">()</span> <span class="o">|</span> <span class="no">nil</span>
          <span class="ss">left</span><span class="p">:</span> <span class="n">t</span><span class="p">()</span> <span class="o">|</span> <span class="no">nil</span><span class="p">,</span>
          <span class="ss">right</span><span class="p">:</span> <span class="n">t</span><span class="p">()</span> <span class="o">|</span> <span class="no">nil</span><span class="p">,</span>
          <span class="ss">size</span><span class="p">:</span> <span class="n">integer</span><span class="p">(),</span>
          <span class="ss">height</span><span class="p">:</span> <span class="n">integer</span><span class="p">(),</span>
  <span class="p">}</span>

  <span class="na">@doc</span> <span class="sh">&#34;&#34;&#34;
</span><span class="sh">  Builds a new Heap
</span><span class="sh">  &#34;&#34;&#34;</span>
  <span class="na">@spec</span> <span class="n">new</span><span class="p">()</span> <span class="o">::</span> <span class="n">t</span><span class="p">()</span>
  <span class="kd">def</span> <span class="n">new</span><span class="p">,</span> <span class="ss">do</span><span class="p">:</span> <span class="err">%</span><span class="n">__MODULE__</span><span class="p">{}</span>
<span class="k">end</span>
</code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>There was a lot of theory covered in this post.
Covering this theory will be extremely useful when the <code>insert</code> and <code>removal</code>
procedures are implemented.
For each of those operations we will leverage the Heap&rsquo;s properties to make sure
we implement each operation in <code>O(log(n))</code> time while also maintaining the heap
properties at each step.</p>
<p>Once that is complete, heapsort will be trivial to implement and we will have
worst case running time of <code>O(log(n))</code> ensured.
implement heapsort.</p>
<p>In the next post, we will implement the <code>O(log(n))</code> insertion of elements. Stay
tuned until then!</p>
]]></content></item><item><title>Max Subarray in Elixir</title><link>https://www.samuelwillis.dev/posts/max-contiguous-sum-in-elixir/</link><pubDate>Thu, 20 May 2021 21:00:50 -0600</pubDate><guid>https://www.samuelwillis.dev/posts/max-contiguous-sum-in-elixir/</guid><description>The maximum subarray problem is defined as follows:
Given an array A find a nonempty, contiguous subarray of A whose values have the largest sum.
It&amp;rsquo;s an interesting little problem that benefits greatly from the use of a divide and conquer algorithm as the runtime goes from O(n^2) for the brute force method to O(nlog(n)) for the divide and conquer method.
Brute Force Method The brute force method is quite simple.</description><content type="html"><![CDATA[<p>The maximum subarray problem is defined as follows:</p>
<p>Given an array <em>A</em> find a nonempty, contiguous subarray of <em>A</em> whose values have the largest sum.</p>
<p>It&rsquo;s an interesting little problem that benefits greatly from the use of a divide and conquer algorithm as the runtime goes from <code>O(n^2)</code> for the brute force method to <code>O(nlog(n))</code> for the divide and conquer method.</p>
<h2 id="brute-force-method">Brute Force Method</h2>
<p>The brute force method is quite simple.</p>
<p>Take every pair of indices <code>x</code> and <code> y</code> s.t. <code>x &lt; y</code> and find the sum of elements given by the subarray <code>A[x..y]</code>.</p>
<p>Since there is <code>nC2</code> ways to chose the pairs of indices, the brute force method is <code>O(n^2)</code>.</p>
<p>This can be drastically improved by divide and conquer.</p>
<h2 id="divide-and-conquer-method">Divide and Conquer Method</h2>
<p>In the method, the array is split into <code>A[lo..mid]</code> and <code>A[mid+1..hi]</code>.
With this split any contiguous subarray must land in one of three places:</p>
<ul>
<li>Entirely in the subarray <code>A[lo..mid]</code></li>
<li>Entirely in the subarray <code>A[mid+1..hi]</code></li>
<li>Crossing the midpoint s.t. <code>low &lt;= i &lt;= mid &lt; j &lt;= hi</code></li>
</ul>
<p>Thus, a maximum subarray must live in exactly one of those places as well.</p>
<p>Finding the maximum subarray of <code>A[lo..mid]</code> and <code>A[mid+1..hi]</code> can each be done recursively.</p>
<p>The maximum subarray crossing the midpoint will be composed of two arrays <code>A[i..mid]</code> and <code>A[mid+1..j]</code> where <code>lo &lt;= i &lt;= mid</code> and <code>mid &lt; j &lt;= hi</code>.</p>
<p>We then compare the sums of each of the 3 maximum subarrays and return the largest sum.</p>
<h3 id="runtime-of-divide-and-conquer-method">Runtime of Divide and Conquer Method</h3>
<p>Here is a quick explanation for the runtime of the Divide and Conquer method.
It is not in-depth at all and I would recommend looking elsewhere for more complete analysis.
This is based off the <a href="https://en.wikipedia.org/wiki/Introduction_to_Algorithms">CLRS Algorithms book</a> analysis and is a very condensed summary.</p>
<p>Since the array is split in half for each recursive call and the base cases are <code>O(1)</code>, the recursion equation is</p>
<pre tabindex="0"><code>T(n) = O(1) if n=1
     = 2T(n/2) + O(n) if n &gt; 1
</code></pre><p>Meaning that the <a href="https://www.programiz.com/dsa/master-theorem">Master Theorem</a> can be applied to solve the equation and the runtime is <code>O(nlog(n))</code>.</p>
<h2 id="implementation">Implementation</h2>
<p>This implementation will return the sum of maximum subarray.
Since it is recursive, it lends itself nicely to implementation in Elixir.
Returning the subarray can also be done with some adjustments to the code, for simplicity it was omitted.</p>
<p>First we will start with base cases of the recursion:</p>
<ul>
<li>For an empty list, the maximum contiguous sum will be <code>0</code>.</li>
<li>For a single element list, the max will be the value of the single element.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">ElixirImpl.DivideAndConquer.MaxContiguousSum</span> <span class="k">do</span>
  <span class="na">@moduledoc</span> <span class="sh">&#34;&#34;&#34;
</span><span class="sh">  Find the maximum contiguous sum in a provided list
</span><span class="sh">  &#34;&#34;&#34;</span>

  <span class="kn">alias</span> <span class="nc">ElixirImpl.ListHelpers</span>

  <span class="na">@doc</span> <span class="sh">&#34;&#34;&#34;
</span><span class="sh">  Find the maximum contiguous sum in the provided list.
</span><span class="sh">  &#34;&#34;&#34;</span>
  <span class="na">@spec</span> <span class="n">find</span><span class="p">(</span><span class="n">list</span><span class="p">())</span> <span class="o">::</span> <span class="n">integer</span><span class="p">()</span>
  <span class="kd">def</span> <span class="n">find</span><span class="p">([]),</span> <span class="ss">do</span><span class="p">:</span> <span class="mi">0</span>
  <span class="kd">def</span> <span class="n">find</span><span class="p">([</span><span class="n">el</span><span class="p">]),</span> <span class="ss">do</span><span class="p">:</span> <span class="n">el</span>

  <span class="kd">def</span> <span class="n">find</span><span class="p">(</span><span class="n">list</span><span class="p">)</span> <span class="k">do</span>
    <span class="c1"># TODO</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><p>Next we will need a way to split the array into two parts.
In practice, I&rsquo;d recommend using <a href="https://hexdocs.pm/elixir/Enum.html#split/2">Enum.split/2</a> but I found implementing my own to be a nice exercise.</p>
<p>To perform the split, the middle index is calculated, then the original list is split into two recursively with elements <code>0..middle</code> in the first array and the remaining elements in the second.</p>
<p>To avoid appending to a list, the left list is built by prepending and then reversed.
Again, a home brewed reverse is used as a learning tool but I&rsquo;d suggest using <a href="https://hexdocs.pm/elixir/Enum.html#reverse/1">Enum.reverse/1</a> in practice.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-elixir" data-lang="elixir">  <span class="na">@doc</span> <span class="sh">&#34;&#34;&#34;
</span><span class="sh">  Split a list into two parts leaving count elements in the first part.
</span><span class="sh">
</span><span class="sh">  </span><span class="err">##</span><span class="sh"> Examples
</span><span class="sh">
</span><span class="sh">    iex&gt; split([1, 2, 3, 4], 2)
</span><span class="sh">    {[1, 2] ,[3, 4]}
</span><span class="sh">
</span><span class="sh">    iex&gt; split([1, 2, 3], 10)
</span><span class="sh">    {[1, 2, 3], []}
</span><span class="sh">
</span><span class="sh">    iex&gt; split([1, 2, 3], 0)
</span><span class="sh">    {[], [1, 2, 3]}
</span><span class="sh">
</span><span class="sh">    iex&gt; split([], 1)
</span><span class="sh">    {[], []}
</span><span class="sh">  &#34;&#34;&#34;</span>
  <span class="na">@spec</span> <span class="n">split</span><span class="p">(</span><span class="n">list</span><span class="p">(),</span> <span class="n">integer</span><span class="p">)</span> <span class="o">::</span> <span class="p">{</span><span class="n">list</span><span class="p">(),</span> <span class="n">list</span><span class="p">()}</span>
  <span class="kd">def</span> <span class="n">split</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">count</span><span class="p">),</span> <span class="ss">do</span><span class="p">:</span> <span class="n">do_split</span><span class="p">({[],</span> <span class="n">list</span><span class="p">},</span> <span class="n">count</span><span class="p">)</span>

  <span class="kd">def</span> <span class="n">do_split</span><span class="p">({</span><span class="n">left</span><span class="p">,</span> <span class="p">[</span><span class="n">head</span> <span class="o">|</span> <span class="n">tail</span><span class="p">]},</span> <span class="n">count</span><span class="p">)</span> <span class="ow">when</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">,</span>
    <span class="ss">do</span><span class="p">:</span> <span class="n">do_split</span><span class="p">({[</span><span class="n">head</span> <span class="o">|</span> <span class="n">left</span><span class="p">],</span> <span class="n">tail</span><span class="p">},</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

  <span class="kd">def</span> <span class="n">do_split</span><span class="p">({</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">},</span> <span class="mi">0</span><span class="p">),</span> <span class="ss">do</span><span class="p">:</span> <span class="p">{</span><span class="n">reverse</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="n">right</span><span class="p">}</span>

  <span class="kd">def</span> <span class="n">do_split</span><span class="p">({</span><span class="n">left</span><span class="p">,</span> <span class="p">[]},</span> <span class="n">_count</span><span class="p">),</span> <span class="ss">do</span><span class="p">:</span> <span class="p">{</span><span class="n">reverse</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="p">[]}</span>

  <span class="na">@doc</span> <span class="sh">&#34;&#34;&#34;
</span><span class="sh">  Reverse a list
</span><span class="sh">
</span><span class="sh">  </span><span class="err">##</span><span class="sh"> Examples
</span><span class="sh">    iex&gt; reverse([])
</span><span class="sh">    []
</span><span class="sh">
</span><span class="sh">    iex&gt; reverse([1, 2, 3])
</span><span class="sh">    [3, 2, 1]
</span><span class="sh">  &#34;&#34;&#34;</span>
  <span class="na">@spec</span> <span class="n">reverse</span><span class="p">(</span><span class="n">list</span><span class="p">())</span> <span class="o">::</span> <span class="n">list</span><span class="p">()</span>
  <span class="kd">def</span> <span class="n">reverse</span><span class="p">(</span><span class="n">list</span><span class="p">),</span> <span class="ss">do</span><span class="p">:</span> <span class="n">do_reverse</span><span class="p">([],</span> <span class="n">list</span><span class="p">)</span>

  <span class="kd">def</span> <span class="n">do_reverse</span><span class="p">([],</span> <span class="p">[</span><span class="n">head</span> <span class="o">|</span> <span class="n">tail</span><span class="p">]),</span> <span class="ss">do</span><span class="p">:</span> <span class="n">do_reverse</span><span class="p">([</span><span class="n">head</span><span class="p">],</span> <span class="n">tail</span><span class="p">)</span>
  <span class="kd">def</span> <span class="n">do_reverse</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="p">[</span><span class="n">head</span> <span class="o">|</span> <span class="n">tail</span><span class="p">]),</span> <span class="ss">do</span><span class="p">:</span> <span class="n">do_reverse</span><span class="p">([</span><span class="n">head</span> <span class="o">|</span> <span class="n">list</span><span class="p">],</span> <span class="n">tail</span><span class="p">)</span>
  <span class="kd">def</span> <span class="n">do_reverse</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="p">[]),</span> <span class="ss">do</span><span class="p">:</span> <span class="n">list</span>
</code></pre></div><p>Adding the middle index calculation, the split, and the recursive calls to <code>find</code> it now looks like:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-elixir" data-lang="elixir">  <span class="kd">def</span> <span class="n">find</span><span class="p">(</span><span class="n">list</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">middle</span> <span class="o">=</span> <span class="n">list</span> <span class="o">|&gt;</span> <span class="n">length</span><span class="p">()</span> <span class="o">|&gt;</span> <span class="n">div</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="p">{</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">}</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">middle</span><span class="p">)</span>

    <span class="n">left_sum</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
    <span class="n">right_sum</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
  <span class="k">end</span>
</code></pre></div><p>The final piece is finding the maximum sum that crosses the middle.
In order to do this, the maximum sum in the array <code>A[lo..mid]</code> is found and then added to the maximum sum from the array going from <code>A[mid+1..hi]</code>.</p>
<p>To find these maximum sums another recursive function is needed.
This function will take a list and add elements together until the sum is no longer smaller than the sum plus the next element.</p>
<p>Using pattern matching and guards this is quite simple.
Care must be taken when finding the sum of the <code>left</code> array as the maximum sum must include the middle element, so it is reversed before being passed to the <code>find_sum/2</code> helper.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-elixir" data-lang="elixir">  <span class="kd">defp</span> <span class="n">find_cross_sum</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">left_sum</span> <span class="o">=</span> <span class="n">left</span> <span class="o">|&gt;</span> <span class="nc">ListHelpers</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span> <span class="o">|&gt;</span> <span class="n">find_sum</span><span class="p">()</span>
    <span class="n">right_sum</span> <span class="o">=</span> <span class="n">find_sum</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

    <span class="n">left_sum</span> <span class="o">+</span> <span class="n">right_sum</span>
  <span class="k">end</span>

  <span class="kd">defp</span> <span class="n">find_sum</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">sum</span> <span class="p">\\</span> <span class="no">nil</span><span class="p">)</span>
  <span class="kd">defp</span> <span class="n">find_sum</span><span class="p">([</span><span class="n">head</span> <span class="o">|</span> <span class="n">tail</span><span class="p">],</span> <span class="no">nil</span><span class="p">),</span> <span class="ss">do</span><span class="p">:</span> <span class="n">find_sum</span><span class="p">(</span><span class="n">tail</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span>
  <span class="kd">defp</span> <span class="n">find_sum</span><span class="p">([</span><span class="n">head</span> <span class="o">|</span> <span class="n">tail</span><span class="p">],</span> <span class="n">sum</span><span class="p">)</span> <span class="ow">when</span> <span class="n">sum</span> <span class="o">&lt;=</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">head</span><span class="p">,</span> <span class="ss">do</span><span class="p">:</span> <span class="n">find_sum</span><span class="p">(</span><span class="n">tail</span><span class="p">,</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">head</span><span class="p">)</span>
  <span class="kd">defp</span> <span class="n">find_sum</span><span class="p">(</span><span class="n">_list</span><span class="p">,</span> <span class="n">sum</span><span class="p">),</span> <span class="ss">do</span><span class="p">:</span> <span class="n">sum</span>
</code></pre></div><p>The find function needs to be updated to find the cross sum, making it look as so:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-elixir" data-lang="elixir">  <span class="kd">def</span> <span class="n">find</span><span class="p">(</span><span class="n">list</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">middle</span> <span class="o">=</span> <span class="n">list</span> <span class="o">|&gt;</span> <span class="n">length</span><span class="p">()</span> <span class="o">|&gt;</span> <span class="n">div</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="p">{</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">}</span> <span class="o">=</span> <span class="nc">ListHelpers</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">middle</span><span class="p">)</span>

    <span class="n">left_sum</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
    <span class="n">right_sum</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
    <span class="n">cross_sum</span> <span class="o">=</span> <span class="n">find_cross_sum</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
  <span class="k">end</span>
</code></pre></div><p>The final piece is returning the maximum of <code>left_sum</code>, <code>right_sum</code>, and <code>cross_sum</code>.
This can be done with a <code>cond</code> statement but I thought a <code>max/3</code> that leverages guards was nicer to read and easier to follow.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-elixir" data-lang="elixir">  <span class="kd">defp</span> <span class="n">max</span><span class="p">(</span><span class="n">left_sum</span><span class="p">,</span> <span class="n">right_sum</span><span class="p">,</span> <span class="n">cross_sum</span><span class="p">)</span> <span class="ow">when</span> <span class="n">left_sum</span> <span class="o">&lt;=</span> <span class="n">right_sum</span> <span class="ow">and</span> <span class="n">cross_sum</span> <span class="o">&lt;=</span> <span class="n">right_sum</span><span class="p">,</span>
    <span class="ss">do</span><span class="p">:</span> <span class="n">right_sum</span>

  <span class="kd">defp</span> <span class="n">max</span><span class="p">(</span><span class="n">left_sum</span><span class="p">,</span> <span class="n">right_sum</span><span class="p">,</span> <span class="n">cross_sum</span><span class="p">)</span> <span class="ow">when</span> <span class="n">right_sum</span> <span class="o">&lt;=</span> <span class="n">left_sum</span> <span class="ow">and</span> <span class="n">cross_sum</span> <span class="o">&lt;=</span> <span class="n">left_sum</span><span class="p">,</span>
    <span class="ss">do</span><span class="p">:</span> <span class="n">left_sum</span>

  <span class="kd">defp</span> <span class="n">max</span><span class="p">(</span><span class="n">_left_sum</span><span class="p">,</span> <span class="n">_right_sum</span><span class="p">,</span> <span class="n">cross_sum</span><span class="p">),</span> <span class="ss">do</span><span class="p">:</span> <span class="n">cross_sum</span>
</code></pre></div><p>Putting this all together the final implementation is</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">ElixirImpl.DivideAndConquer.MaxContiguousSum</span> <span class="k">do</span>
  <span class="na">@moduledoc</span> <span class="sh">&#34;&#34;&#34;
</span><span class="sh">  Find the maximum contiguous sum in a provided list
</span><span class="sh">  &#34;&#34;&#34;</span>

  <span class="kn">alias</span> <span class="nc">ElixirImpl.ListHelpers</span>

  <span class="na">@doc</span> <span class="sh">&#34;&#34;&#34;
</span><span class="sh">  Find the maximum contiguous sum in the provided list.
</span><span class="sh">  &#34;&#34;&#34;</span>
  <span class="na">@spec</span> <span class="n">find</span><span class="p">(</span><span class="n">list</span><span class="p">())</span> <span class="o">::</span> <span class="n">integer</span><span class="p">()</span>
  <span class="kd">def</span> <span class="n">find</span><span class="p">([]),</span> <span class="ss">do</span><span class="p">:</span> <span class="mi">0</span>
  <span class="kd">def</span> <span class="n">find</span><span class="p">([</span><span class="n">el</span><span class="p">]),</span> <span class="ss">do</span><span class="p">:</span> <span class="n">el</span>

  <span class="kd">def</span> <span class="n">find</span><span class="p">(</span><span class="n">list</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">middle</span> <span class="o">=</span> <span class="n">list</span> <span class="o">|&gt;</span> <span class="n">length</span><span class="p">()</span> <span class="o">|&gt;</span> <span class="n">div</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="p">{</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">}</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">middle</span><span class="p">)</span>

    <span class="n">left_sum</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
    <span class="n">right_sum</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
    <span class="n">cross_sum</span> <span class="o">=</span> <span class="n">find_cross_sum</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="n">max</span><span class="p">(</span><span class="n">left_sum</span><span class="p">,</span> <span class="n">right_sum</span><span class="p">,</span> <span class="n">cross_sum</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="kd">defp</span> <span class="n">find_cross_sum</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">left_sum</span> <span class="o">=</span> <span class="n">left</span> <span class="o">|&gt;</span> <span class="n">reverse</span><span class="p">()</span> <span class="o">|&gt;</span> <span class="n">find_sum</span><span class="p">()</span>
    <span class="n">right_sum</span> <span class="o">=</span> <span class="n">find_sum</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

    <span class="n">left_sum</span> <span class="o">+</span> <span class="n">right_sum</span>
  <span class="k">end</span>

  <span class="c1"># Find max sum helper</span>
  <span class="na">@spec</span> <span class="n">find_sum</span><span class="p">(</span><span class="n">list</span><span class="p">(),</span> <span class="no">nil</span> <span class="o">|</span> <span class="n">integer</span><span class="p">())</span> <span class="o">::</span> <span class="n">integer</span><span class="p">()</span>
  <span class="kd">defp</span> <span class="n">find_sum</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">sum</span> <span class="p">\\</span> <span class="no">nil</span><span class="p">)</span>
  <span class="kd">defp</span> <span class="n">find_sum</span><span class="p">([</span><span class="n">head</span> <span class="o">|</span> <span class="n">tail</span><span class="p">],</span> <span class="no">nil</span><span class="p">),</span> <span class="ss">do</span><span class="p">:</span> <span class="n">find_sum</span><span class="p">(</span><span class="n">tail</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span>
  <span class="kd">defp</span> <span class="n">find_sum</span><span class="p">([</span><span class="n">head</span> <span class="o">|</span> <span class="n">tail</span><span class="p">],</span> <span class="n">sum</span><span class="p">)</span> <span class="ow">when</span> <span class="n">sum</span> <span class="o">&lt;=</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">head</span><span class="p">,</span> <span class="ss">do</span><span class="p">:</span> <span class="n">find_sum</span><span class="p">(</span><span class="n">tail</span><span class="p">,</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">head</span><span class="p">)</span>
  <span class="kd">defp</span> <span class="n">find_sum</span><span class="p">(</span><span class="n">_list</span><span class="p">,</span> <span class="n">sum</span><span class="p">),</span> <span class="ss">do</span><span class="p">:</span> <span class="n">sum</span>

  <span class="c1"># Max of 3 integer helper</span>
  <span class="na">@spec</span> <span class="n">max</span><span class="p">(</span><span class="n">integer</span><span class="p">(),</span> <span class="n">integer</span><span class="p">(),</span> <span class="n">integer</span><span class="p">())</span> <span class="o">::</span> <span class="n">integer</span><span class="p">()</span>
  <span class="kd">defp</span> <span class="n">max</span><span class="p">(</span><span class="n">left_sum</span><span class="p">,</span> <span class="n">right_sum</span><span class="p">,</span> <span class="n">cross_sum</span><span class="p">)</span> <span class="ow">when</span> <span class="n">left_sum</span> <span class="o">&lt;=</span> <span class="n">right_sum</span> <span class="ow">and</span> <span class="n">cross_sum</span> <span class="o">&lt;=</span> <span class="n">right_sum</span><span class="p">,</span>
    <span class="ss">do</span><span class="p">:</span> <span class="n">right_sum</span>

  <span class="kd">defp</span> <span class="n">max</span><span class="p">(</span><span class="n">left_sum</span><span class="p">,</span> <span class="n">right_sum</span><span class="p">,</span> <span class="n">cross_sum</span><span class="p">)</span> <span class="ow">when</span> <span class="n">right_sum</span> <span class="o">&lt;=</span> <span class="n">left_sum</span> <span class="ow">and</span> <span class="n">cross_sum</span> <span class="o">&lt;=</span> <span class="n">left_sum</span><span class="p">,</span>
    <span class="ss">do</span><span class="p">:</span> <span class="n">left_sum</span>

  <span class="kd">defp</span> <span class="n">max</span><span class="p">(</span><span class="n">_left_sum</span><span class="p">,</span> <span class="n">_right_sum</span><span class="p">,</span> <span class="n">cross_sum</span><span class="p">),</span> <span class="ss">do</span><span class="p">:</span> <span class="n">cross_sum</span>

  <span class="c1"># Split list helper</span>
  <span class="na">@spec</span> <span class="n">split</span><span class="p">(</span><span class="n">list</span><span class="p">(),</span> <span class="n">integer</span><span class="p">)</span> <span class="o">::</span> <span class="p">{</span><span class="n">list</span><span class="p">(),</span> <span class="n">list</span><span class="p">()}</span>
  <span class="kd">defp</span> <span class="n">split</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">count</span><span class="p">),</span> <span class="ss">do</span><span class="p">:</span> <span class="n">do_split</span><span class="p">({[],</span> <span class="n">list</span><span class="p">},</span> <span class="n">count</span><span class="p">)</span>

  <span class="kd">defp</span> <span class="n">do_split</span><span class="p">({</span><span class="n">left</span><span class="p">,</span> <span class="p">[</span><span class="n">head</span> <span class="o">|</span> <span class="n">tail</span><span class="p">]},</span> <span class="n">count</span><span class="p">)</span> <span class="ow">when</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">,</span>
    <span class="ss">do</span><span class="p">:</span> <span class="n">do_split</span><span class="p">({[</span><span class="n">head</span> <span class="o">|</span> <span class="n">left</span><span class="p">],</span> <span class="n">tail</span><span class="p">},</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

  <span class="kd">defp</span> <span class="n">do_split</span><span class="p">({</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">},</span> <span class="mi">0</span><span class="p">),</span> <span class="ss">do</span><span class="p">:</span> <span class="p">{</span><span class="n">reverse</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="n">right</span><span class="p">}</span>

  <span class="kd">defp</span> <span class="n">do_split</span><span class="p">({</span><span class="n">left</span><span class="p">,</span> <span class="p">[]},</span> <span class="n">_count</span><span class="p">),</span> <span class="ss">do</span><span class="p">:</span> <span class="p">{</span><span class="n">reverse</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="p">[]}</span>

  <span class="c1"># Reverse list helper</span>
  <span class="na">@spec</span> <span class="n">reverse</span><span class="p">(</span><span class="n">list</span><span class="p">())</span> <span class="o">::</span> <span class="n">list</span><span class="p">()</span>
  <span class="kd">def</span> <span class="n">reverse</span><span class="p">(</span><span class="n">list</span><span class="p">),</span> <span class="ss">do</span><span class="p">:</span> <span class="n">do_reverse</span><span class="p">([],</span> <span class="n">list</span><span class="p">)</span>

  <span class="kd">defp</span> <span class="n">do_reverse</span><span class="p">([],</span> <span class="p">[</span><span class="n">head</span> <span class="o">|</span> <span class="n">tail</span><span class="p">]),</span> <span class="ss">do</span><span class="p">:</span> <span class="n">do_reverse</span><span class="p">([</span><span class="n">head</span><span class="p">],</span> <span class="n">tail</span><span class="p">)</span>
  <span class="kd">defp</span> <span class="n">do_reverse</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="p">[</span><span class="n">head</span> <span class="o">|</span> <span class="n">tail</span><span class="p">]),</span> <span class="ss">do</span><span class="p">:</span> <span class="n">do_reverse</span><span class="p">([</span><span class="n">head</span> <span class="o">|</span> <span class="n">list</span><span class="p">],</span> <span class="n">tail</span><span class="p">)</span>
  <span class="kd">defp</span> <span class="n">do_reverse</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="p">[]),</span> <span class="ss">do</span><span class="p">:</span> <span class="n">list</span>
<span class="k">end</span>
</code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>Finding the maximum contiguous sum in Elixir is quite simple to do.
Especially after wrapping ones head around the recursion involved.</p>
<p>I think that this is easier to follow than the imperative version as well.</p>
<p>I hope this was useful for anyone looking into algorithms in functional languages!</p>
<p><a href="https://github.com/SamuelWillis/algorithms/blob/main/elixir/lib/divide_and_conquer/max_contiguous_sum.ex">Click for the full
implementation</a>.</p>
<p><a href="https://github.com/SamuelWillis/algorithms/tree/main/notes/divide-and-conquer/maximum-subarray">And here is my full set of Insertion Sort
notes</a>.</p>
]]></content></item><item><title>Insertion Sort in Elixir</title><link>https://www.samuelwillis.dev/posts/insertion-sort-in-elixir/</link><pubDate>Sat, 24 Apr 2021 12:59:20 -0600</pubDate><guid>https://www.samuelwillis.dev/posts/insertion-sort-in-elixir/</guid><description>Departing from Data Structures such as Queues and Stacks this post will cover the insertion sort algorithm in Elixir.
Insertion sort is one of the first sorting algorithms introduced in Computer Science as its quite simple.
Insertion sort is quite efficient on small data sets and it does the sort in place. Meaning it has O(1) (constant) memory space requirements. Unfortunately, this does not hold true in Elixir as recursion is used causing the space-complexity to be O(n) (linear).</description><content type="html"><![CDATA[<p>Departing from Data Structures such as <a href="https://www.samuelwillis.dev/posts/queues-in-elixir/">Queues</a>
and <a href="https://www.samuelwillis.dev/posts/stacks-in-elixir/">Stacks</a> this post will cover the insertion
sort algorithm in Elixir.</p>
<p>Insertion sort is one of the first sorting algorithms introduced in Computer
Science as its quite simple.</p>
<p>Insertion sort is quite efficient on small data sets and it does the sort in
place.
Meaning it has <code>O(1)</code> (constant) memory space requirements.
Unfortunately, this does not hold true in Elixir as recursion is used causing
the space-complexity to be <code>O(n)</code> (linear).</p>
<h2 id="method">Method</h2>
<p>In insertion sort, the array into is split into two &ldquo;piles&rdquo;.</p>
<p>On the left pile are the sorted elements and on the right pile are the unsorted.</p>
<p>For each element on the right (unsorted), we compare it to elements in the left
(sorted) pile until the element from the right pile is in its sorted position in
the array.</p>
<p>If the left hand element is larger than the right hand element, we move the left
hand element to the &ldquo;right&rdquo; one position and repeat.</p>
<p>If the left hand element is less than or equal to the right hand element, we
place the right hand element into the position to the &ldquo;right&rdquo; of the current
left hand position.</p>
<h2 id="code">Code</h2>
<p>In imperative languages, insertion sort is most commonly implemented using for
loops and while loops.</p>
<p>Elixir does not have loops, which can be a little tricky to navigate when you
first start learning Elixir.</p>
<p>Instead of loops, Elixir provides pattern matching and recursion.</p>
<p>Placing the insertion sort implementation into a module, the setup will be as
follows:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">ElixirImpl.Sorting.InsertionSort</span> <span class="k">do</span>
  <span class="na">@moduledoc</span> <span class="sh">&#34;&#34;&#34;
</span><span class="sh">  Simple insertion sort implementation
</span><span class="sh">  &#34;&#34;&#34;</span>

  <span class="na">@doc</span> <span class="sh">&#34;&#34;&#34;
</span><span class="sh">  Sort the provided list
</span><span class="sh">
</span><span class="sh">  </span><span class="err">##</span><span class="sh"> Examples
</span><span class="sh">
</span><span class="sh">    iex&gt; InsertionSort.sort([])
</span><span class="sh">    []
</span><span class="sh">
</span><span class="sh">    iex&gt; InsertionSort.sort([1])
</span><span class="sh">    [1]
</span><span class="sh">
</span><span class="sh">    iex&gt; InsertionSort.sort([1, 0])
</span><span class="sh">    [0, 1]
</span><span class="sh">
</span><span class="sh">    iex&gt; InsertionSort.sort([1, -1, 0])
</span><span class="sh">    [-1, 0, 1]
</span><span class="sh">  &#34;&#34;&#34;</span>
  <span class="na">@spec</span> <span class="n">sort</span><span class="p">(</span><span class="n">list</span><span class="p">())</span> <span class="o">::</span> <span class="n">list</span><span class="p">()</span>
  <span class="kd">def</span> <span class="n">sort</span><span class="p">([]),</span> <span class="ss">do</span><span class="p">:</span> <span class="p">[]</span>
  <span class="kd">def</span> <span class="n">sort</span><span class="p">([</span><span class="n">first</span><span class="p">]),</span> <span class="ss">do</span><span class="p">:</span> <span class="p">[</span><span class="n">first</span><span class="p">]</span>
  <span class="kd">def</span> <span class="n">sort</span><span class="p">([</span><span class="n">first</span> <span class="o">|</span> <span class="n">rest</span><span class="p">]),</span> <span class="ss">do</span><span class="p">:</span> <span class="n">do_sort</span><span class="p">([</span><span class="n">first</span><span class="p">],</span> <span class="n">rest</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div><p>Note: only Lists were supported in this implementation for simplicity.</p>
<p>The main sorting logic will come in the form of two private recursive functions.</p>
<p>The first, <code>do_sort/2</code> will handle looping over each element of the array and
placing it into the correct position amongst the sorted elements.</p>
<p>To do this an accumulator will be used to store the elements in sorted position.</p>
<p><code>do_sort/2</code> accepts the sorted elements as its first parameter and the remaining
unsorted elements as its second parameter.</p>
<p>It will consist of 2 clauses.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-elixir" data-lang="elixir">  <span class="kd">defp</span> <span class="n">do_sort</span><span class="p">(</span><span class="n">sorted</span><span class="p">,</span> <span class="n">_unsorted</span> <span class="o">=</span> <span class="p">[</span><span class="n">head</span> <span class="o">|</span> <span class="n">tail</span><span class="p">]),</span> <span class="ss">do</span><span class="p">:</span> <span class="n">do_sort</span><span class="p">(</span><span class="n">insert</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">sorted</span><span class="p">),</span> <span class="n">tail</span><span class="p">)</span>
  <span class="kd">defp</span> <span class="n">do_sort</span><span class="p">(</span><span class="n">sorted</span><span class="p">,</span> <span class="p">[]),</span> <span class="ss">do</span><span class="p">:</span> <span class="n">sorted</span>
</code></pre></div><p>The second private function is <code>insert/2</code>.
It takes care of looping through the sorted list and placing an element in the
correct position.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-elixir" data-lang="elixir">  <span class="c1"># if no elements to compare against in sorted list, return element as a list</span>
  <span class="kd">defp</span> <span class="n">insert</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">_sorted</span> <span class="o">=</span> <span class="p">[]),</span> <span class="ss">do</span><span class="p">:</span> <span class="p">[</span><span class="n">element</span><span class="p">]</span>
  <span class="c1"># if element is less than the first element of the sorted list, insert at front</span>
  <span class="kd">defp</span> <span class="n">insert</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="p">[</span><span class="n">min</span> <span class="o">|</span> <span class="n">_rest</span><span class="p">]</span> <span class="o">=</span> <span class="n">sorted</span><span class="p">)</span> <span class="ow">when</span> <span class="n">element</span> <span class="o">&lt;=</span> <span class="n">min</span><span class="p">,</span> <span class="ss">do</span><span class="p">:</span> <span class="p">[</span><span class="n">element</span> <span class="o">|</span> <span class="n">sorted</span><span class="p">]</span>
  <span class="c1"># Otherwise element is larger than min and we check it against the next sorted element</span>
  <span class="kd">defp</span> <span class="n">insert</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="p">[</span><span class="n">min</span> <span class="o">|</span> <span class="n">rest</span><span class="p">]),</span> <span class="ss">do</span><span class="p">:</span> <span class="p">[</span><span class="n">min</span> <span class="o">|</span> <span class="n">insert</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">rest</span><span class="p">)]</span>
</code></pre></div><p>Putting it all together the implementation is:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">ElixirImpl.Sorting.InsertionSort</span> <span class="k">do</span>
  <span class="na">@moduledoc</span> <span class="sh">&#34;&#34;&#34;
</span><span class="sh">  Simple insertion sort implementation
</span><span class="sh">  &#34;&#34;&#34;</span>

  <span class="na">@doc</span> <span class="sh">&#34;&#34;&#34;
</span><span class="sh">  Sort the provided list
</span><span class="sh">
</span><span class="sh">  </span><span class="err">##</span><span class="sh"> Examples
</span><span class="sh">
</span><span class="sh">    iex&gt; InsertionSort.sort([])
</span><span class="sh">    []
</span><span class="sh">
</span><span class="sh">    iex&gt; InsertionSort.sort([1])
</span><span class="sh">    [1]
</span><span class="sh">
</span><span class="sh">    iex&gt; InsertionSort.sort([1, 0])
</span><span class="sh">    [0, 1]
</span><span class="sh">
</span><span class="sh">    iex&gt; InsertionSort.sort([1, -1, 0])
</span><span class="sh">    [-1, 0, 1]
</span><span class="sh">  &#34;&#34;&#34;</span>
  <span class="na">@spec</span> <span class="n">sort</span><span class="p">(</span><span class="n">list</span><span class="p">())</span> <span class="o">::</span> <span class="n">list</span><span class="p">()</span>
  <span class="kd">def</span> <span class="n">sort</span><span class="p">([]),</span> <span class="ss">do</span><span class="p">:</span> <span class="p">[]</span>
  <span class="kd">def</span> <span class="n">sort</span><span class="p">([</span><span class="n">first</span><span class="p">]),</span> <span class="ss">do</span><span class="p">:</span> <span class="p">[</span><span class="n">first</span><span class="p">]</span>
  <span class="kd">def</span> <span class="n">sort</span><span class="p">([</span><span class="n">first</span> <span class="o">|</span> <span class="n">rest</span><span class="p">]),</span> <span class="ss">do</span><span class="p">:</span> <span class="n">do_sort</span><span class="p">([</span><span class="n">first</span><span class="p">],</span> <span class="n">rest</span><span class="p">)</span>

  <span class="kd">defp</span> <span class="n">do_sort</span><span class="p">(</span><span class="n">sorted</span><span class="p">,</span> <span class="n">_unsorted</span> <span class="o">=</span> <span class="p">[</span><span class="n">head</span> <span class="o">|</span> <span class="n">tail</span><span class="p">]),</span>
    <span class="ss">do</span><span class="p">:</span> <span class="n">do_sort</span><span class="p">(</span><span class="n">insert</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">sorted</span><span class="p">),</span> <span class="n">tail</span><span class="p">)</span>
  <span class="kd">defp</span> <span class="n">do_sort</span><span class="p">(</span><span class="n">sorted</span><span class="p">,</span> <span class="p">[]),</span>
    <span class="ss">do</span><span class="p">:</span> <span class="n">sorted</span>

  <span class="c1"># if no elements to compare against in sorted, return element as a list</span>
  <span class="kd">defp</span> <span class="n">insert</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">_sorted</span> <span class="o">=</span> <span class="p">[]),</span>
    <span class="ss">do</span><span class="p">:</span> <span class="p">[</span><span class="n">element</span><span class="p">]</span>
  <span class="c1"># if element is less than the first element of the sorted list, insert at front</span>
  <span class="kd">defp</span> <span class="n">insert</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="p">[</span><span class="n">min</span> <span class="o">|</span> <span class="n">_rest</span><span class="p">]</span> <span class="o">=</span> <span class="n">sorted</span><span class="p">)</span> <span class="ow">when</span> <span class="n">element</span> <span class="o">&lt;=</span> <span class="n">min</span><span class="p">,</span>
    <span class="ss">do</span><span class="p">:</span> <span class="p">[</span><span class="n">element</span> <span class="o">|</span> <span class="n">sorted</span><span class="p">]</span>
  <span class="c1"># Otherwise try insert element into remainder of sorted list</span>
  <span class="kd">defp</span> <span class="n">insert</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="p">[</span><span class="n">min</span> <span class="o">|</span> <span class="n">rest</span><span class="p">]),</span>
    <span class="ss">do</span><span class="p">:</span> <span class="p">[</span><span class="n">min</span> <span class="o">|</span> <span class="n">insert</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">rest</span><span class="p">)]</span>
<span class="k">end</span>
</code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>Insertion sort is a simple sorting algorithm and implementing it in Elixir was a
great way to get familiar with <a href="https://en.wikipedia.org/wiki/Recursion_(computer_science)">recursion</a>
and <a href="https://en.wikipedia.org/wiki/Tail_call">tail-call recursion</a>.
It was also a great exercise to increase comfort with pattern matches and
looping lists.</p>
<p>This implementation did lose the <code>O(1)</code> space complexity of an imperative
implementation, but that loss holds true for most recursive implementations as
space is needed on the stack for all the function calls.</p>
<p><a href="https://github.com/SamuelWillis/algorithms/blob/main/elixir/lib/sorting/insertion_sort.ex">Click for the full
implementation</a>.</p>
<p><a href="https://github.com/SamuelWillis/algorithms/tree/main/notes/sorting/insertion-sort">And here is my full set of Insertion Sort
notes</a>.</p>
]]></content></item><item><title>Queues in Elixir</title><link>https://www.samuelwillis.dev/posts/queues-in-elixir/</link><pubDate>Tue, 13 Apr 2021 18:36:07 -0600</pubDate><guid>https://www.samuelwillis.dev/posts/queues-in-elixir/</guid><description>Continuing on from my previous Stacks in Elixir post today I will cover implementing Queues in Elixir.
Queues operate on a First In First out (FIFO) policy, meaning the first item placed onto the queue is the first to be removed.
These are again essentially sugar for lists but there&amp;rsquo;s a few gotchas to get around when implementing them in Elixir. The main being that appending to lists can be an expensive operation in Elixir.</description><content type="html"><![CDATA[<p>Continuing on from my previous <a href="https://www.samuelwillis.dev/posts/stacks-in-elixir/">Stacks in Elixir</a> post
today I will cover implementing Queues in Elixir.</p>
<p>Queues operate on a First In First out (FIFO) policy, meaning the first item
placed onto the queue is the first to be removed.</p>
<p>These are again essentially sugar for lists but there&rsquo;s a few gotchas to get
around when implementing them in Elixir.
The main being that appending to lists can be an expensive operation in Elixir.</p>
<p>But first, the queue operations.</p>
<h2 id="operations">Operations</h2>
<p>Formally, all the operations for Queues are:</p>
<pre tabindex="0"><code>Enqueue(Q, x)
  if Queue-Full(Q) throw Overflow Error

  Q[Q.tail] = x
  if Q.tail == Q.length -1
    Q = 0
  else Q.tail++
  return x

Dequeue(Q)
  if Queue-Empty(Q) throw Underflow Error

  x = Q[Q.head]
  if Q.head == Q.length - 1
    Q.head = 0
  else Q.head++
  return x

Queue-Empty(Q)
  return Q.tail == Q.head

Queue-Full(Q)
  if Q.head = Q.tail + 1 OR (Q.tail = Q.length - 1 AND Q.head = 0)
    return true
  else
    return false
</code></pre><p>This implementation will omit the full operation as a list will be used to store
the items on the queue and they do not require manual resizing, unlike arrays
would.</p>
<h2 id="implementation">Implementation</h2>
<p>The implementation will again use a list to store the items in the queue.</p>
<p>Normally when adding an item to the queue it would be added to the back.
This would require appending to a list and in Elixir, that can be very
expensive.
Appending the new item would be possible but is <a href="https://hexdocs.pm/elixir/Kernel.html#++/2">warned
against</a>.
The official suggestion is to prepend and then reverse the list.</p>
<p>This implementation will follow the documentation&rsquo;s advice and prepend any new
items to the queue.
Then to dequeue it will reverse the elements and return the last one.</p>
<p>I admit this is probably overkill and appending would probably be fine but I
wanted to write my own reverse function to practice my Elixir.</p>
<p>In practice, appending would likely be fine unless the Queue was expected to be
extremely large and then using the
<a href="https://hexdocs.pm/elixir/Enum.html#reverse/1"><code>Enum.reverse</code></a> built in functions
would be better than rolling my own as it leverages the highly optimized
<code>:list.reverse</code>
from Erlang.</p>
<h3 id="set-up">Set up</h3>
<p>As in the <a href="https://www.samuelwillis.dev/posts/stacks-in-elixir/#implementation">Stack implementation</a> a struct will be used to represent
the Queue.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">ElixirImpl.DataStructure.Queue</span> <span class="k">do</span>
  <span class="na">@moduledoc</span> <span class="sh">&#34;&#34;&#34;
</span><span class="sh">  Queue implementation.
</span><span class="sh">  &#34;&#34;&#34;</span>
  <span class="kd">defstruct</span> <span class="ss">elements</span><span class="p">:</span> <span class="p">[]</span>

  <span class="na">@typep</span> <span class="n">t</span> <span class="o">::</span> <span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span>
           <span class="ss">elements</span><span class="p">:</span> <span class="p">[</span><span class="n">any</span><span class="p">()]</span>
         <span class="p">}</span>
<span class="k">end</span>
</code></pre></div><h3 id="enqueue">Enqueue</h3>
<p>Because this implementation places the new items at the front of the list of
elements the enqueue implementation is quite simple.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-elixir" data-lang="elixir">  <span class="na">@doc</span> <span class="sh">&#34;&#34;&#34;
</span><span class="sh">  Add an item into a queue.
</span><span class="sh">
</span><span class="sh">  </span><span class="err">##</span><span class="sh"> Examples
</span><span class="sh">   iex&gt; Queue.enqueue(%Queue{elements: []}, &#34;one&#34;)
</span><span class="sh">    %Queue{elements: [&#34;one&#34;]}
</span><span class="sh">
</span><span class="sh">    iex&gt; Queue.enqueue(%Queue{elements: [&#34;one&#34;]}, &#34;two&#34;)
</span><span class="sh">    %Queue{elements: [&#34;two&#34;, &#34;one&#34;]}
</span><span class="sh">  &#34;&#34;&#34;</span>
  <span class="kd">def</span> <span class="n">enqueue</span><span class="p">(</span><span class="err">%</span><span class="n">__MODULE__</span><span class="p">{}</span> <span class="o">=</span> <span class="n">queue</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">do</span>
    <span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span>
      <span class="n">queue</span>
      <span class="o">|</span> <span class="ss">elements</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span> <span class="o">|</span> <span class="n">queue</span><span class="o">.</span><span class="n">elements</span><span class="p">]</span>
    <span class="p">}</span>
  <span class="k">end</span>
</code></pre></div><h4 id="dequeue">Dequeue</h4>
<p>Dequeueing is a little trickier as the list of elements will have the oldest
item at the end of the list.</p>
<p>As mentioned in the <a href="https://www.samuelwillis.dev/posts/queues-in-elixir/#implementation">Implementation Section</a> some list reversals will need to be
performed.</p>
<p>There are two reversals total, the first is to get the oldest item, the second
is to put the list back into the &ldquo;correct&rdquo; order.</p>
<p>In the case we dequeue an item, a tuple is returned consisting of the <code>:ok</code>
atom, the item, and the queue with the list of elements omitting the dequeued
item.</p>
<p>If the list of elements is empty a <code>{:error, &quot;Empty Queue&quot;}</code> tuple is returned.</p>
<p>Putting it together it looks as follows:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-elixir" data-lang="elixir">  <span class="na">@doc</span> <span class="sh">&#34;&#34;&#34;
</span><span class="sh">  Remove an item from the queue.
</span><span class="sh">
</span><span class="sh">  </span><span class="err">##</span><span class="sh"> Examples
</span><span class="sh">    iex&gt; Queue.dequeue(%Queue{elements: [&#34;first&#34;]})
</span><span class="sh">    {:ok, &#34;first&#34;, %Queue{elements: []}
</span><span class="sh">
</span><span class="sh">    iex&gt; Queue.dequeue(%Queue{elements: [&#34;third&#34;, &#34;second&#34;, &#34;first&#34;]})
</span><span class="sh">    {:ok, &#34;first&#34;, %Queue{elements: [&#34;third&#34;, &#34;second&#34;]}}
</span><span class="sh">
</span><span class="sh">    iex&gt; Queue.dequeue(%Queue{elements: []})
</span><span class="sh">    {:error, &#34;Empty Queue&#34;}
</span><span class="sh">  &#34;&#34;&#34;</span>
  <span class="kd">def</span> <span class="n">dequeue</span><span class="p">(</span><span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span><span class="ss">elements</span><span class="p">:</span> <span class="p">[]}),</span> <span class="ss">do</span><span class="p">:</span> <span class="p">{</span><span class="ss">:error</span><span class="p">,</span> <span class="s2">&#34;Empty Queue&#34;</span><span class="p">}</span>

  <span class="c1"># Reverses the list of elements and grabs the &#34;first&#34; queued element and the</span>
  <span class="c1"># remainder of the elements. Then reverses the remainder to place them back</span>
  <span class="c1"># into their correct order</span>
  <span class="kd">def</span> <span class="n">dequeue</span><span class="p">(</span><span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span><span class="ss">elements</span><span class="p">:</span> <span class="n">elements</span><span class="p">})</span> <span class="k">do</span>
    <span class="p">[</span><span class="n">item</span> <span class="o">|</span> <span class="n">elements</span><span class="p">]</span> <span class="o">=</span> <span class="n">reverse_elements</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span>

    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span>
     <span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span>
       <span class="ss">elements</span><span class="p">:</span> <span class="n">reverse_elements</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span>
     <span class="p">}}</span>
  <span class="k">end</span>
</code></pre></div><h3 id="empty">Empty</h3>
<p>The empty operation is quite simple using pattern matching.</p>
<p>If the Stack&rsquo;s elements matches a non empty list, we return <code>false</code>.
Otherwise, return <code>true</code>.
The <a href="https://hexdocs.pm/elixir/master/naming-conventions.html#trailing-question-mark-foo">trailing question
mark</a>
naming convention is used in the implementation.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-elixir" data-lang="elixir">  <span class="na">@doc</span> <span class="sh">&#34;&#34;&#34;
</span><span class="sh">  Check the if queue is empty
</span><span class="sh">
</span><span class="sh">  </span><span class="err">##</span><span class="sh"> Examples
</span><span class="sh">    iex&gt; Queue.empty?(%Queue{elements: [&#34;item one&#34;]})
</span><span class="sh">    false
</span><span class="sh">
</span><span class="sh">    iex&gt; Queue.empty?(%Queue{elements: []})
</span><span class="sh">    true
</span><span class="sh">  &#34;&#34;&#34;</span>
  <span class="kd">def</span> <span class="n">empty?</span><span class="p">(</span><span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span><span class="ss">elements</span><span class="p">:</span> <span class="p">[</span><span class="n">_head</span> <span class="o">|</span> <span class="n">_tail</span><span class="p">]}),</span> <span class="ss">do</span><span class="p">:</span> <span class="no">false</span>
  <span class="kd">def</span> <span class="n">empty?</span><span class="p">(</span><span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span><span class="ss">elements</span><span class="p">:</span> <span class="p">[]}),</span> <span class="ss">do</span><span class="p">:</span> <span class="no">true</span>
</code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>Implementing a simple Queue is a fairly easy task in Elixir.
It could be made even simpler if
<a href="https://hexdocs.pm/elixir/Kernel.html#++/2">Kernel.++/2</a> was used to append the
new items to the back of the list of elements.</p>
<p>As it stands, implementing a simple Queue was a great way to get familiar with
Elixir&rsquo;s lists and their limitations as well as start digging into idiomatic
ways to handle lists.</p>
<p><a href="https://github.com/SamuelWillis/algorithms/blob/main/elixir/lib/data_structures/queue.ex">Click for the full
implementation</a>.</p>
<p><a href="https://github.com/SamuelWillis/algorithms/tree/main/notes/data-structures/queue">And here is my full set of Queue
notes</a>.</p>
]]></content></item><item><title>Stacks in Elixir</title><link>https://www.samuelwillis.dev/posts/stacks-in-elixir/</link><pubDate>Sun, 11 Apr 2021 15:12:45 -0600</pubDate><guid>https://www.samuelwillis.dev/posts/stacks-in-elixir/</guid><description>Stacks are one of the most basic data structures in Computer Science. Nonetheless, they are quite useful and used often.
They operate under the Last In First Out (LIFO) policy, meaning the last object placed onto the stack is the first one to be removed from it.
In Elixir they are essentially syntactical sugar for Lists but implementing them was a nice way to get acquainted with Structs and basic pattern matching.</description><content type="html"><![CDATA[<p>Stacks are one of the most basic data structures in Computer Science.
Nonetheless, they are quite useful and used often.</p>
<p>They operate under the Last In First Out (LIFO) policy, meaning the last object
placed onto the stack is the first one to be removed from it.</p>
<p>In Elixir they are essentially syntactical sugar for
<a href="https://hexdocs.pm/elixir/List.html">Lists</a> but implementing them was a nice
way to get acquainted with <a href="https://elixir-lang.org/getting-started/structs.html">Structs</a>
and basic <a href="https://elixir-lang.org/getting-started/pattern-matching.html">pattern
matching</a>.</p>
<h2 id="operations">Operations</h2>
<p>Formally, the operations for a Stack are <strong>push</strong>, <strong>pop</strong>, <strong>empty</strong>, and <strong>full</strong>.
They typically include checks for <em>overflow errors</em> (pushing to a full stack) and
<em>underflow errors</em> (popping from an empty stack).</p>
<pre tabindex="0"><code>Push(S, x)
  if Full(S) throw Overflow Error
  S[++S.top] = x

Pop(S)
  if Empty(S) throw Underflow Error
  return S[--S.top]

Empty(S)
  if count(S) == 0:
    return True
  else
    return False

Full(S)
  if S.top == S.length
    return True
  else
    return False
</code></pre><h2 id="implementation">Implementation</h2>
<p>The Elixir implementation will use a linked list.
This is because we do not have access to a traditional/imperative style arrays in
Elixir.</p>
<p>Linked lists do not have a static size and, as such, they do not require
resizing when too many elements are added to the stack.
Because of this each operation will take constant time in the <strong>worst
case</strong>.
This does come at the cost of more space used to store each item.</p>
<p>A <a href="https://elixir-lang.org/getting-started/structs.html">Struct</a> will be used to
represent a Stack.
A field called <code>elements</code> will be used to store the list of elements.
Each item in the elements list can have any type.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">ElixirImpl.DataStructure.Stack</span> <span class="k">do</span>
  <span class="na">@moduledoc</span> <span class="sh">&#34;&#34;&#34;
</span><span class="sh">  Stack implementation.
</span><span class="sh">
</span><span class="sh">  This is essentially sugar for Elixir Lists, but is here to show how basic
</span><span class="sh">  operations should work on a stack.
</span><span class="sh">  &#34;&#34;&#34;</span>
  <span class="kd">defstruct</span> <span class="ss">elements</span><span class="p">:</span> <span class="p">[]</span>

  <span class="na">@typep</span> <span class="n">t</span> <span class="o">::</span> <span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span>
           <span class="ss">elements</span><span class="p">:</span> <span class="p">[</span><span class="n">any</span><span class="p">()]</span>
         <span class="p">}</span>
<span class="k">end</span>
</code></pre></div><h3 id="push">Push</h3>
<p>Lets add the push operation.</p>
<p>Since the elements struct key will always exist the <code>|</code> operator to can be
used to update the elements key in the struct without worrying about an error.</p>
<p>Thus the <code>push</code> operation looks like so:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-elixir" data-lang="elixir">  <span class="na">@doc</span> <span class="sh">&#34;&#34;&#34;
</span><span class="sh">  Push an item onto a stack.
</span><span class="sh">
</span><span class="sh">  </span><span class="err">##</span><span class="sh"> Examples
</span><span class="sh">    iex&gt; Stack.push(%Stack{elements: []}, &#34;one&#34;)
</span><span class="sh">    %Stack{elements: [&#34;one&#34;]}
</span><span class="sh">
</span><span class="sh">    iex&gt; Stack.push(%Stack{elements: [&#34;one&#34;]}, &#34;two&#34;)
</span><span class="sh">    %Stack{elements: [&#34;two&#34;, &#34;one&#34;]}
</span><span class="sh">  &#34;&#34;&#34;</span>
  <span class="na">@spec</span> <span class="n">push</span><span class="p">(</span><span class="n">__MODULE__</span><span class="o">.</span><span class="n">t</span><span class="p">(),</span> <span class="n">any</span><span class="p">())</span> <span class="o">::</span> <span class="n">__MODULE__</span><span class="o">.</span><span class="n">t</span><span class="p">()</span>
  <span class="kd">def</span> <span class="n">push</span><span class="p">(</span><span class="err">%</span><span class="n">__MODULE__</span><span class="p">{}</span> <span class="o">=</span> <span class="n">stack</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">do</span>
    <span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span>
      <span class="n">stack</span>
      <span class="o">|</span> <span class="ss">elements</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span> <span class="o">|</span> <span class="n">stack</span><span class="o">.</span><span class="n">elements</span><span class="p">]</span>
    <span class="p">}</span>
  <span class="k">end</span>
</code></pre></div><h3 id="pop">Pop</h3>
<p>Next, the <strong>pop</strong> operation.</p>
<p>For the pop, a check for a empty elements list will be needed.</p>
<p>This check is done using pattern matching.
If the Stack&rsquo;s elements matches an empty list, an error tuple is returned with a
reason.</p>
<p>Pattern matching is also used when the elements list is non empty.
In this case, the <code>head</code> and <code>tail</code> of the elements list is matched against.
The Stack then has its elements updated to be the matched <code>tail</code> and a tuple is
returned consisting of a <code>:ok</code> atom, the matched <code>head</code>, and the updated Stack.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-elixir" data-lang="elixir">  <span class="na">@doc</span> <span class="sh">&#34;&#34;&#34;
</span><span class="sh">  Pop an item off the top of the stack
</span><span class="sh">
</span><span class="sh">  </span><span class="err">##</span><span class="sh"> Examples
</span><span class="sh">    iex&gt; Stack.pop(%Stack{elements: [&#34;item one&#34;]})
</span><span class="sh">    {:ok, &#34;item one&#34;, %Stack{elements: []}}
</span><span class="sh">
</span><span class="sh">    iex&gt; Stack.pop(%Stack{elements: [&#34;item two&#34;, &#34;item one&#34;]})
</span><span class="sh">    {:ok, &#34;item two&#34;, %Stack{elements: [&#34;item one&#34;]}}
</span><span class="sh">
</span><span class="sh">    iex&gt; Stack.pop(%Stack{elements: []})
</span><span class="sh">    {:error, &#34;Empty Stack&#34;}
</span><span class="sh">  &#34;&#34;&#34;</span>
  <span class="na">@spec</span> <span class="n">pop</span><span class="p">(</span><span class="n">__MODULE__</span><span class="o">.</span><span class="n">t</span><span class="p">())</span> <span class="o">::</span> <span class="p">{</span><span class="ss">:error</span><span class="p">,</span> <span class="nc">String</span><span class="o">.</span><span class="n">t</span><span class="p">()}</span> <span class="o">|</span> <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">any</span><span class="p">(),</span> <span class="n">__MODULE__</span><span class="o">.</span><span class="n">t</span><span class="p">()}</span>
  <span class="kd">def</span> <span class="n">pop</span><span class="p">(</span><span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span><span class="ss">elements</span><span class="p">:</span> <span class="p">[]}),</span> <span class="ss">do</span><span class="p">:</span> <span class="p">{</span><span class="ss">:error</span><span class="p">,</span> <span class="s2">&#34;Empty Stack&#34;</span><span class="p">}</span>
  <span class="kd">def</span> <span class="n">pop</span><span class="p">(</span><span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span><span class="ss">elements</span><span class="p">:</span> <span class="p">[</span><span class="n">top</span> <span class="o">|</span> <span class="n">rest</span><span class="p">]}),</span> <span class="ss">do</span><span class="p">:</span> <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span><span class="ss">elements</span><span class="p">:</span> <span class="n">rest</span><span class="p">}}</span>
</code></pre></div><h3 id="empty">Empty</h3>
<p>The empty operation is quite simple using pattern matching.</p>
<p>If the Stack&rsquo;s elements matches a non empty list, we return <code>false</code>.
Otherwise, return <code>true</code>.
The <a href="https://hexdocs.pm/elixir/master/naming-conventions.html#trailing-question-mark-foo">trailing question
mark</a>
naming convention is used in the implementation.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-elixir" data-lang="elixir">  <span class="na">@doc</span> <span class="sh">&#34;&#34;&#34;
</span><span class="sh">  Check if stack is empty
</span><span class="sh">
</span><span class="sh">  </span><span class="err">##</span><span class="sh"> Examples
</span><span class="sh">    iex&gt; Stack.empty?(%Stack{elements: [&#34;item one&#34;]})
</span><span class="sh">    false
</span><span class="sh">
</span><span class="sh">    iex&gt; Stack.empty?(%Stack{elements: []})
</span><span class="sh">    true
</span><span class="sh">  &#34;&#34;&#34;</span>
  <span class="kd">def</span> <span class="n">empty?</span><span class="p">(</span><span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span><span class="ss">elements</span><span class="p">:</span> <span class="p">[</span><span class="n">_head</span> <span class="o">|</span> <span class="n">_tail</span><span class="p">]}),</span> <span class="ss">do</span><span class="p">:</span> <span class="no">false</span>
  <span class="kd">def</span> <span class="n">empty?</span><span class="p">(</span><span class="err">%</span><span class="n">__MODULE__</span><span class="p">{</span><span class="ss">elements</span><span class="p">:</span> <span class="p">[]}),</span> <span class="ss">do</span><span class="p">:</span> <span class="no">true</span>
</code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>Stacks are a rudimentary data structure but they are used constantly in
programming.
They help us allocate memory, parse code, add ways to undo actions, and much
more.</p>
<p>Implementing a Stack in Elixir is really just sugar for built in Elixir lists
but was a nice way to get acquainted with pattern matching and structs.</p>
<p><a href="https://github.com/SamuelWillis/algorithms/blob/main/elixir/lib/data_structures/stack.ex">Click for the full
implementation</a>.</p>
<p><a href="https://github.com/SamuelWillis/algorithms/tree/main/notes/data-structures/stack">And here is my full set of Stack
notes</a>.</p>
]]></content></item><item><title>Hello World</title><link>https://www.samuelwillis.dev/posts/hello-world/</link><pubDate>Sun, 11 Apr 2021 14:34:21 -0600</pubDate><guid>https://www.samuelwillis.dev/posts/hello-world/</guid><description>Welcome to my blog, where I aim to document (re)learning core developer ideas.
Much of it will be done in the functional language Elixir
I hope you find something useful here.</description><content type="html"><![CDATA[<p>Welcome to my blog, where I aim to document (re)learning core developer ideas.</p>
<p>Much of it will be done in the functional language
<a href="https://elixir-lang.org/">Elixir</a></p>
<p>I hope you find something useful here.</p>
]]></content></item></channel></rss>