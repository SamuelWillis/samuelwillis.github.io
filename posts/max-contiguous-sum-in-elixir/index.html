<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta http-equiv=x-ua-compatible content="ie=edge">
<meta itemprop=name content="Max Subarray in Elixir">
<meta itemprop=description content="The maximum subarray problem is defined as follows:
Given an array A find a nonempty, contiguous subarray of A whose values have the largest sum.
It&rsquo;s an interesting little problem that benefits greatly from the use of a divide and conquer algorithm as the runtime goes from O(n^2) for the brute force method to O(nlog(n)) for the divide and conquer method.
Brute Force Method The brute force method is quite simple."><meta itemprop=datePublished content="2021-05-20T21:00:50-06:00">
<meta itemprop=dateModified content="2021-05-20T21:00:50-06:00">
<meta itemprop=wordCount content="1364">
<meta itemprop=keywords content="Elixir,Algorithms,DivideAndConquer,Implementation,Code,MaxiumSubarray,ContiguousSum,"><meta property="og:title" content="Max Subarray in Elixir">
<meta property="og:description" content="The maximum subarray problem is defined as follows:
Given an array A find a nonempty, contiguous subarray of A whose values have the largest sum.
It&rsquo;s an interesting little problem that benefits greatly from the use of a divide and conquer algorithm as the runtime goes from O(n^2) for the brute force method to O(nlog(n)) for the divide and conquer method.
Brute Force Method The brute force method is quite simple.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://www.samuelwillis.dev/posts/max-contiguous-sum-in-elixir/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-05-20T21:00:50-06:00">
<meta property="article:modified_time" content="2021-05-20T21:00:50-06:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Max Subarray in Elixir">
<meta name=twitter:description content="The maximum subarray problem is defined as follows:
Given an array A find a nonempty, contiguous subarray of A whose values have the largest sum.
It&rsquo;s an interesting little problem that benefits greatly from the use of a divide and conquer algorithm as the runtime goes from O(n^2) for the brute force method to O(nlog(n)) for the divide and conquer method.
Brute Force Method The brute force method is quite simple.">
<link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png>
<link rel=manifest href=/site.webmanifest>
<link rel=mask-icon href=/safari-pinned-tab.svg color>
<link rel="shortcut icon" href=/favicon.ico>
<title>Max Subarray in Elixir</title>
<link rel=stylesheet href=https://www.samuelwillis.dev/css/style.min.f74778e3020c87c304fb5982e09b92ba63a5c7f202996d4c7283d6057acfe9c1.css integrity="sha256-90d44wIMh8ME+1mC4JuSumOlx/ICmW1McoPWBXrP6cE=" crossorigin=anonymous>
</head>
<body id=page>
<header id=site-header class="animated slideInUp">
<div class="hdr-wrapper section-inner">
<div class=hdr-left>
<div class=site-branding>
<a href=https://www.samuelwillis.dev>samuel willis</a>
</div>
<nav class="site-nav hide-in-mobile">
<a href=https://www.samuelwillis.dev/about/>about</a>
<a href=https://www.samuelwillis.dev/posts/>posts</a>
</nav>
</div>
<div class="hdr-right hdr-icons">
<span class="hdr-social hide-in-mobile"><a href=mailto:samuel.w.h.willis@gmail.com target=_blank rel="noopener me" title=Email><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a><a href=https://github.com/SamuelWillis target=_blank rel="noopener me" title=Github><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://www.linkedin.com/in/willissamuel/ target=_blank rel="noopener me" title=Linkedin><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></span><button id=menu-btn class=hdr-btn title=Menu><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button>
</div>
</div>
</header>
<div id=mobile-menu class="animated fast">
<ul>
<li><a href=https://www.samuelwillis.dev/about/>about</a></li>
<li><a href=https://www.samuelwillis.dev/posts/>posts</a></li>
</ul>
</div>
<main class="site-main section-inner animated fadeIn faster">
<article class=thin>
<header class=post-header>
<div class=post-meta><span>May 20, 2021</span></div>
<h1>Max Subarray in Elixir</h1>
</header>
<div class=content>
<p>The maximum subarray problem is defined as follows:</p>
<p>Given an array <em>A</em> find a nonempty, contiguous subarray of <em>A</em> whose values have the largest sum.</p>
<p>It&rsquo;s an interesting little problem that benefits greatly from the use of a divide and conquer algorithm as the runtime goes from <code>O(n^2)</code> for the brute force method to <code>O(nlog(n))</code> for the divide and conquer method.</p>
<h2 id=brute-force-method>Brute Force Method<a href=#brute-force-method class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2>
<p>The brute force method is quite simple.</p>
<p>Take every pair of indices <code>x</code> and <code> y</code> s.t. <code>x &lt; y</code> and find the sum of elements given by the subarray <code>A[x..y]</code>.</p>
<p>Since there is <code>nC2</code> ways to chose the pairs of indices, the brute force method is <code>O(n^2)</code>.</p>
<p>This can be drastically improved by divide and conquer.</p>
<h2 id=divide-and-conquer-method>Divide and Conquer Method<a href=#divide-and-conquer-method class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2>
<p>In the method, the array is split into <code>A[lo..mid]</code> and <code>A[mid+1..hi]</code>.
With this split any contiguous subarray must land in one of three places:</p>
<ul>
<li>Entirely in the subarray <code>A[lo..mid]</code></li>
<li>Entirely in the subarray <code>A[mid+1..hi]</code></li>
<li>Crossing the midpoint s.t. <code>low &lt;= i &lt;= mid &lt; j &lt;= hi</code></li>
</ul>
<p>Thus, a maximum subarray must live in exactly one of those places as well.</p>
<p>Finding the maximum subarray of <code>A[lo..mid]</code> and <code>A[mid+1..hi]</code> can each be done recursively.</p>
<p>The maximum subarray crossing the midpoint will be composed of two arrays <code>A[i..mid]</code> and <code>A[mid+1..j]</code> where <code>lo &lt;= i &lt;= mid</code> and <code>mid &lt; j &lt;= hi</code>.</p>
<p>We then compare the sums of each of the 3 maximum subarrays and return the largest sum.</p>
<h3 id=runtime-of-divide-and-conquer-method>Runtime of Divide and Conquer Method<a href=#runtime-of-divide-and-conquer-method class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3>
<p>Here is a quick explanation for the runtime of the Divide and Conquer method.
It is not in-depth at all and I would recommend looking elsewhere for more complete analysis.
This is based off the <a href=https://en.wikipedia.org/wiki/Introduction_to_Algorithms>CLRS Algorithms book</a> analysis and is a very condensed summary.</p>
<p>Since the array is split in half for each recursive call and the base cases are <code>O(1)</code>, the recursion equation is</p>
<pre tabindex=0><code>T(n) = O(1) if n=1
     = 2T(n/2) + O(n) if n &gt; 1
</code></pre><p>Meaning that the <a href=https://www.programiz.com/dsa/master-theorem>Master Theorem</a> can be applied to solve the equation and the runtime is <code>O(nlog(n))</code>.</p>
<h2 id=implementation>Implementation<a href=#implementation class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2>
<p>This implementation will return the sum of maximum subarray.
Since it is recursive, it lends itself nicely to implementation in Elixir.
Returning the subarray can also be done with some adjustments to the code, for simplicity it was omitted.</p>
<p>First we will start with base cases of the recursion:</p>
<ul>
<li>For an empty list, the maximum contiguous sum will be <code>0</code>.</li>
<li>For a single element list, the max will be the value of the single element.</li>
</ul>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir><span class=kd>defmodule</span> <span class=nc>ElixirImpl.DivideAndConquer.MaxContiguousSum</span> <span class=k>do</span>
  <span class=na>@moduledoc</span> <span class=sh>&#34;&#34;&#34;
</span><span class=sh>  Find the maximum contiguous sum in a provided list
</span><span class=sh>  &#34;&#34;&#34;</span>

  <span class=kn>alias</span> <span class=nc>ElixirImpl.ListHelpers</span>

  <span class=na>@doc</span> <span class=sh>&#34;&#34;&#34;
</span><span class=sh>  Find the maximum contiguous sum in the provided list.
</span><span class=sh>  &#34;&#34;&#34;</span>
  <span class=na>@spec</span> <span class=n>find</span><span class=p>(</span><span class=n>list</span><span class=p>())</span> <span class=o>::</span> <span class=n>integer</span><span class=p>()</span>
  <span class=kd>def</span> <span class=n>find</span><span class=p>([]),</span> <span class=ss>do</span><span class=p>:</span> <span class=mi>0</span>
  <span class=kd>def</span> <span class=n>find</span><span class=p>([</span><span class=n>el</span><span class=p>]),</span> <span class=ss>do</span><span class=p>:</span> <span class=n>el</span>

  <span class=kd>def</span> <span class=n>find</span><span class=p>(</span><span class=n>list</span><span class=p>)</span> <span class=k>do</span>
    <span class=c1># TODO</span>
  <span class=k>end</span>
<span class=k>end</span>
</code></pre></div><p>Next we will need a way to split the array into two parts.
In practice, I&rsquo;d recommend using <a href=https://hexdocs.pm/elixir/Enum.html#split/2>Enum.split/2</a> but I found implementing my own to be a nice exercise.</p>
<p>To perform the split, the middle index is calculated, then the original list is split into two recursively with elements <code>0..middle</code> in the first array and the remaining elements in the second.</p>
<p>To avoid appending to a list, the left list is built by prepending and then reversed.
Again, a home brewed reverse is used as a learning tool but I&rsquo;d suggest using <a href=https://hexdocs.pm/elixir/Enum.html#reverse/1>Enum.reverse/1</a> in practice.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir>  <span class=na>@doc</span> <span class=sh>&#34;&#34;&#34;
</span><span class=sh>  Split a list into two parts leaving count elements in the first part.
</span><span class=sh>
</span><span class=sh>  </span><span class=err>##</span><span class=sh> Examples
</span><span class=sh>
</span><span class=sh>    iex&gt; split([1, 2, 3, 4], 2)
</span><span class=sh>    {[1, 2] ,[3, 4]}
</span><span class=sh>
</span><span class=sh>    iex&gt; split([1, 2, 3], 10)
</span><span class=sh>    {[1, 2, 3], []}
</span><span class=sh>
</span><span class=sh>    iex&gt; split([1, 2, 3], 0)
</span><span class=sh>    {[], [1, 2, 3]}
</span><span class=sh>
</span><span class=sh>    iex&gt; split([], 1)
</span><span class=sh>    {[], []}
</span><span class=sh>  &#34;&#34;&#34;</span>
  <span class=na>@spec</span> <span class=n>split</span><span class=p>(</span><span class=n>list</span><span class=p>(),</span> <span class=n>integer</span><span class=p>)</span> <span class=o>::</span> <span class=p>{</span><span class=n>list</span><span class=p>(),</span> <span class=n>list</span><span class=p>()}</span>
  <span class=kd>def</span> <span class=n>split</span><span class=p>(</span><span class=n>list</span><span class=p>,</span> <span class=n>count</span><span class=p>),</span> <span class=ss>do</span><span class=p>:</span> <span class=n>do_split</span><span class=p>({[],</span> <span class=n>list</span><span class=p>},</span> <span class=n>count</span><span class=p>)</span>

  <span class=kd>def</span> <span class=n>do_split</span><span class=p>({</span><span class=n>left</span><span class=p>,</span> <span class=p>[</span><span class=n>head</span> <span class=o>|</span> <span class=n>tail</span><span class=p>]},</span> <span class=n>count</span><span class=p>)</span> <span class=ow>when</span> <span class=mi>0</span> <span class=o>&lt;</span> <span class=n>count</span><span class=p>,</span>
    <span class=ss>do</span><span class=p>:</span> <span class=n>do_split</span><span class=p>({[</span><span class=n>head</span> <span class=o>|</span> <span class=n>left</span><span class=p>],</span> <span class=n>tail</span><span class=p>},</span> <span class=n>count</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>

  <span class=kd>def</span> <span class=n>do_split</span><span class=p>({</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>},</span> <span class=mi>0</span><span class=p>),</span> <span class=ss>do</span><span class=p>:</span> <span class=p>{</span><span class=n>reverse</span><span class=p>(</span><span class=n>left</span><span class=p>),</span> <span class=n>right</span><span class=p>}</span>

  <span class=kd>def</span> <span class=n>do_split</span><span class=p>({</span><span class=n>left</span><span class=p>,</span> <span class=p>[]},</span> <span class=n>_count</span><span class=p>),</span> <span class=ss>do</span><span class=p>:</span> <span class=p>{</span><span class=n>reverse</span><span class=p>(</span><span class=n>left</span><span class=p>),</span> <span class=p>[]}</span>

  <span class=na>@doc</span> <span class=sh>&#34;&#34;&#34;
</span><span class=sh>  Reverse a list
</span><span class=sh>
</span><span class=sh>  </span><span class=err>##</span><span class=sh> Examples
</span><span class=sh>    iex&gt; reverse([])
</span><span class=sh>    []
</span><span class=sh>
</span><span class=sh>    iex&gt; reverse([1, 2, 3])
</span><span class=sh>    [3, 2, 1]
</span><span class=sh>  &#34;&#34;&#34;</span>
  <span class=na>@spec</span> <span class=n>reverse</span><span class=p>(</span><span class=n>list</span><span class=p>())</span> <span class=o>::</span> <span class=n>list</span><span class=p>()</span>
  <span class=kd>def</span> <span class=n>reverse</span><span class=p>(</span><span class=n>list</span><span class=p>),</span> <span class=ss>do</span><span class=p>:</span> <span class=n>do_reverse</span><span class=p>([],</span> <span class=n>list</span><span class=p>)</span>

  <span class=kd>def</span> <span class=n>do_reverse</span><span class=p>([],</span> <span class=p>[</span><span class=n>head</span> <span class=o>|</span> <span class=n>tail</span><span class=p>]),</span> <span class=ss>do</span><span class=p>:</span> <span class=n>do_reverse</span><span class=p>([</span><span class=n>head</span><span class=p>],</span> <span class=n>tail</span><span class=p>)</span>
  <span class=kd>def</span> <span class=n>do_reverse</span><span class=p>(</span><span class=n>list</span><span class=p>,</span> <span class=p>[</span><span class=n>head</span> <span class=o>|</span> <span class=n>tail</span><span class=p>]),</span> <span class=ss>do</span><span class=p>:</span> <span class=n>do_reverse</span><span class=p>([</span><span class=n>head</span> <span class=o>|</span> <span class=n>list</span><span class=p>],</span> <span class=n>tail</span><span class=p>)</span>
  <span class=kd>def</span> <span class=n>do_reverse</span><span class=p>(</span><span class=n>list</span><span class=p>,</span> <span class=p>[]),</span> <span class=ss>do</span><span class=p>:</span> <span class=n>list</span>
</code></pre></div><p>Adding the middle index calculation, the split, and the recursive calls to <code>find</code> it now looks like:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir>  <span class=kd>def</span> <span class=n>find</span><span class=p>(</span><span class=n>list</span><span class=p>)</span> <span class=k>do</span>
    <span class=n>middle</span> <span class=o>=</span> <span class=n>list</span> <span class=o>|&gt;</span> <span class=n>length</span><span class=p>()</span> <span class=o>|&gt;</span> <span class=n>div</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>

    <span class=p>{</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>}</span> <span class=o>=</span> <span class=n>split</span><span class=p>(</span><span class=n>list</span><span class=p>,</span> <span class=n>middle</span><span class=p>)</span>

    <span class=n>left_sum</span> <span class=o>=</span> <span class=n>find</span><span class=p>(</span><span class=n>left</span><span class=p>)</span>
    <span class=n>right_sum</span> <span class=o>=</span> <span class=n>find</span><span class=p>(</span><span class=n>right</span><span class=p>)</span>
  <span class=k>end</span>
</code></pre></div><p>The final piece is finding the maximum sum that crosses the middle.
In order to do this, the maximum sum in the array <code>A[lo..mid]</code> is found and then added to the maximum sum from the array going from <code>A[mid+1..hi]</code>.</p>
<p>To find these maximum sums another recursive function is needed.
This function will take a list and add elements together until the sum is no longer smaller than the sum plus the next element.</p>
<p>Using pattern matching and guards this is quite simple.
Care must be taken when finding the sum of the <code>left</code> array as the maximum sum must include the middle element, so it is reversed before being passed to the <code>find_sum/2</code> helper.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir>  <span class=kd>defp</span> <span class=n>find_cross_sum</span><span class=p>(</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>)</span> <span class=k>do</span>
    <span class=n>left_sum</span> <span class=o>=</span> <span class=n>left</span> <span class=o>|&gt;</span> <span class=nc>ListHelpers</span><span class=o>.</span><span class=n>reverse</span><span class=p>()</span> <span class=o>|&gt;</span> <span class=n>find_sum</span><span class=p>()</span>
    <span class=n>right_sum</span> <span class=o>=</span> <span class=n>find_sum</span><span class=p>(</span><span class=n>right</span><span class=p>)</span>

    <span class=n>left_sum</span> <span class=o>+</span> <span class=n>right_sum</span>
  <span class=k>end</span>

  <span class=kd>defp</span> <span class=n>find_sum</span><span class=p>(</span><span class=n>list</span><span class=p>,</span> <span class=n>sum</span> <span class=p>\\</span> <span class=no>nil</span><span class=p>)</span>
  <span class=kd>defp</span> <span class=n>find_sum</span><span class=p>([</span><span class=n>head</span> <span class=o>|</span> <span class=n>tail</span><span class=p>],</span> <span class=no>nil</span><span class=p>),</span> <span class=ss>do</span><span class=p>:</span> <span class=n>find_sum</span><span class=p>(</span><span class=n>tail</span><span class=p>,</span> <span class=n>head</span><span class=p>)</span>
  <span class=kd>defp</span> <span class=n>find_sum</span><span class=p>([</span><span class=n>head</span> <span class=o>|</span> <span class=n>tail</span><span class=p>],</span> <span class=n>sum</span><span class=p>)</span> <span class=ow>when</span> <span class=n>sum</span> <span class=o>&lt;=</span> <span class=n>sum</span> <span class=o>+</span> <span class=n>head</span><span class=p>,</span> <span class=ss>do</span><span class=p>:</span> <span class=n>find_sum</span><span class=p>(</span><span class=n>tail</span><span class=p>,</span> <span class=n>sum</span> <span class=o>+</span> <span class=n>head</span><span class=p>)</span>
  <span class=kd>defp</span> <span class=n>find_sum</span><span class=p>(</span><span class=n>_list</span><span class=p>,</span> <span class=n>sum</span><span class=p>),</span> <span class=ss>do</span><span class=p>:</span> <span class=n>sum</span>
</code></pre></div><p>The find function needs to be updated to find the cross sum, making it look as so:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir>  <span class=kd>def</span> <span class=n>find</span><span class=p>(</span><span class=n>list</span><span class=p>)</span> <span class=k>do</span>
    <span class=n>middle</span> <span class=o>=</span> <span class=n>list</span> <span class=o>|&gt;</span> <span class=n>length</span><span class=p>()</span> <span class=o>|&gt;</span> <span class=n>div</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>

    <span class=p>{</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>}</span> <span class=o>=</span> <span class=nc>ListHelpers</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=n>list</span><span class=p>,</span> <span class=n>middle</span><span class=p>)</span>

    <span class=n>left_sum</span> <span class=o>=</span> <span class=n>find</span><span class=p>(</span><span class=n>left</span><span class=p>)</span>
    <span class=n>right_sum</span> <span class=o>=</span> <span class=n>find</span><span class=p>(</span><span class=n>right</span><span class=p>)</span>
    <span class=n>cross_sum</span> <span class=o>=</span> <span class=n>find_cross_sum</span><span class=p>(</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>)</span>
  <span class=k>end</span>
</code></pre></div><p>The final piece is returning the maximum of <code>left_sum</code>, <code>right_sum</code>, and <code>cross_sum</code>.
This can be done with a <code>cond</code> statement but I thought a <code>max/3</code> that leverages guards was nicer to read and easier to follow.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir>  <span class=kd>defp</span> <span class=n>max</span><span class=p>(</span><span class=n>left_sum</span><span class=p>,</span> <span class=n>right_sum</span><span class=p>,</span> <span class=n>cross_sum</span><span class=p>)</span> <span class=ow>when</span> <span class=n>left_sum</span> <span class=o>&lt;=</span> <span class=n>right_sum</span> <span class=ow>and</span> <span class=n>cross_sum</span> <span class=o>&lt;=</span> <span class=n>right_sum</span><span class=p>,</span>
    <span class=ss>do</span><span class=p>:</span> <span class=n>right_sum</span>

  <span class=kd>defp</span> <span class=n>max</span><span class=p>(</span><span class=n>left_sum</span><span class=p>,</span> <span class=n>right_sum</span><span class=p>,</span> <span class=n>cross_sum</span><span class=p>)</span> <span class=ow>when</span> <span class=n>right_sum</span> <span class=o>&lt;=</span> <span class=n>left_sum</span> <span class=ow>and</span> <span class=n>cross_sum</span> <span class=o>&lt;=</span> <span class=n>left_sum</span><span class=p>,</span>
    <span class=ss>do</span><span class=p>:</span> <span class=n>left_sum</span>

  <span class=kd>defp</span> <span class=n>max</span><span class=p>(</span><span class=n>_left_sum</span><span class=p>,</span> <span class=n>_right_sum</span><span class=p>,</span> <span class=n>cross_sum</span><span class=p>),</span> <span class=ss>do</span><span class=p>:</span> <span class=n>cross_sum</span>
</code></pre></div><p>Putting this all together the final implementation is</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir><span class=kd>defmodule</span> <span class=nc>ElixirImpl.DivideAndConquer.MaxContiguousSum</span> <span class=k>do</span>
  <span class=na>@moduledoc</span> <span class=sh>&#34;&#34;&#34;
</span><span class=sh>  Find the maximum contiguous sum in a provided list
</span><span class=sh>  &#34;&#34;&#34;</span>

  <span class=kn>alias</span> <span class=nc>ElixirImpl.ListHelpers</span>

  <span class=na>@doc</span> <span class=sh>&#34;&#34;&#34;
</span><span class=sh>  Find the maximum contiguous sum in the provided list.
</span><span class=sh>  &#34;&#34;&#34;</span>
  <span class=na>@spec</span> <span class=n>find</span><span class=p>(</span><span class=n>list</span><span class=p>())</span> <span class=o>::</span> <span class=n>integer</span><span class=p>()</span>
  <span class=kd>def</span> <span class=n>find</span><span class=p>([]),</span> <span class=ss>do</span><span class=p>:</span> <span class=mi>0</span>
  <span class=kd>def</span> <span class=n>find</span><span class=p>([</span><span class=n>el</span><span class=p>]),</span> <span class=ss>do</span><span class=p>:</span> <span class=n>el</span>

  <span class=kd>def</span> <span class=n>find</span><span class=p>(</span><span class=n>list</span><span class=p>)</span> <span class=k>do</span>
    <span class=n>middle</span> <span class=o>=</span> <span class=n>list</span> <span class=o>|&gt;</span> <span class=n>length</span><span class=p>()</span> <span class=o>|&gt;</span> <span class=n>div</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>

    <span class=p>{</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>}</span> <span class=o>=</span> <span class=n>split</span><span class=p>(</span><span class=n>list</span><span class=p>,</span> <span class=n>middle</span><span class=p>)</span>

    <span class=n>left_sum</span> <span class=o>=</span> <span class=n>find</span><span class=p>(</span><span class=n>left</span><span class=p>)</span>
    <span class=n>right_sum</span> <span class=o>=</span> <span class=n>find</span><span class=p>(</span><span class=n>right</span><span class=p>)</span>
    <span class=n>cross_sum</span> <span class=o>=</span> <span class=n>find_cross_sum</span><span class=p>(</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>)</span>

    <span class=n>max</span><span class=p>(</span><span class=n>left_sum</span><span class=p>,</span> <span class=n>right_sum</span><span class=p>,</span> <span class=n>cross_sum</span><span class=p>)</span>
  <span class=k>end</span>

  <span class=kd>defp</span> <span class=n>find_cross_sum</span><span class=p>(</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>)</span> <span class=k>do</span>
    <span class=n>left_sum</span> <span class=o>=</span> <span class=n>left</span> <span class=o>|&gt;</span> <span class=n>reverse</span><span class=p>()</span> <span class=o>|&gt;</span> <span class=n>find_sum</span><span class=p>()</span>
    <span class=n>right_sum</span> <span class=o>=</span> <span class=n>find_sum</span><span class=p>(</span><span class=n>right</span><span class=p>)</span>

    <span class=n>left_sum</span> <span class=o>+</span> <span class=n>right_sum</span>
  <span class=k>end</span>

  <span class=c1># Find max sum helper</span>
  <span class=na>@spec</span> <span class=n>find_sum</span><span class=p>(</span><span class=n>list</span><span class=p>(),</span> <span class=no>nil</span> <span class=o>|</span> <span class=n>integer</span><span class=p>())</span> <span class=o>::</span> <span class=n>integer</span><span class=p>()</span>
  <span class=kd>defp</span> <span class=n>find_sum</span><span class=p>(</span><span class=n>list</span><span class=p>,</span> <span class=n>sum</span> <span class=p>\\</span> <span class=no>nil</span><span class=p>)</span>
  <span class=kd>defp</span> <span class=n>find_sum</span><span class=p>([</span><span class=n>head</span> <span class=o>|</span> <span class=n>tail</span><span class=p>],</span> <span class=no>nil</span><span class=p>),</span> <span class=ss>do</span><span class=p>:</span> <span class=n>find_sum</span><span class=p>(</span><span class=n>tail</span><span class=p>,</span> <span class=n>head</span><span class=p>)</span>
  <span class=kd>defp</span> <span class=n>find_sum</span><span class=p>([</span><span class=n>head</span> <span class=o>|</span> <span class=n>tail</span><span class=p>],</span> <span class=n>sum</span><span class=p>)</span> <span class=ow>when</span> <span class=n>sum</span> <span class=o>&lt;=</span> <span class=n>sum</span> <span class=o>+</span> <span class=n>head</span><span class=p>,</span> <span class=ss>do</span><span class=p>:</span> <span class=n>find_sum</span><span class=p>(</span><span class=n>tail</span><span class=p>,</span> <span class=n>sum</span> <span class=o>+</span> <span class=n>head</span><span class=p>)</span>
  <span class=kd>defp</span> <span class=n>find_sum</span><span class=p>(</span><span class=n>_list</span><span class=p>,</span> <span class=n>sum</span><span class=p>),</span> <span class=ss>do</span><span class=p>:</span> <span class=n>sum</span>

  <span class=c1># Max of 3 integer helper</span>
  <span class=na>@spec</span> <span class=n>max</span><span class=p>(</span><span class=n>integer</span><span class=p>(),</span> <span class=n>integer</span><span class=p>(),</span> <span class=n>integer</span><span class=p>())</span> <span class=o>::</span> <span class=n>integer</span><span class=p>()</span>
  <span class=kd>defp</span> <span class=n>max</span><span class=p>(</span><span class=n>left_sum</span><span class=p>,</span> <span class=n>right_sum</span><span class=p>,</span> <span class=n>cross_sum</span><span class=p>)</span> <span class=ow>when</span> <span class=n>left_sum</span> <span class=o>&lt;=</span> <span class=n>right_sum</span> <span class=ow>and</span> <span class=n>cross_sum</span> <span class=o>&lt;=</span> <span class=n>right_sum</span><span class=p>,</span>
    <span class=ss>do</span><span class=p>:</span> <span class=n>right_sum</span>

  <span class=kd>defp</span> <span class=n>max</span><span class=p>(</span><span class=n>left_sum</span><span class=p>,</span> <span class=n>right_sum</span><span class=p>,</span> <span class=n>cross_sum</span><span class=p>)</span> <span class=ow>when</span> <span class=n>right_sum</span> <span class=o>&lt;=</span> <span class=n>left_sum</span> <span class=ow>and</span> <span class=n>cross_sum</span> <span class=o>&lt;=</span> <span class=n>left_sum</span><span class=p>,</span>
    <span class=ss>do</span><span class=p>:</span> <span class=n>left_sum</span>

  <span class=kd>defp</span> <span class=n>max</span><span class=p>(</span><span class=n>_left_sum</span><span class=p>,</span> <span class=n>_right_sum</span><span class=p>,</span> <span class=n>cross_sum</span><span class=p>),</span> <span class=ss>do</span><span class=p>:</span> <span class=n>cross_sum</span>

  <span class=c1># Split list helper</span>
  <span class=na>@spec</span> <span class=n>split</span><span class=p>(</span><span class=n>list</span><span class=p>(),</span> <span class=n>integer</span><span class=p>)</span> <span class=o>::</span> <span class=p>{</span><span class=n>list</span><span class=p>(),</span> <span class=n>list</span><span class=p>()}</span>
  <span class=kd>defp</span> <span class=n>split</span><span class=p>(</span><span class=n>list</span><span class=p>,</span> <span class=n>count</span><span class=p>),</span> <span class=ss>do</span><span class=p>:</span> <span class=n>do_split</span><span class=p>({[],</span> <span class=n>list</span><span class=p>},</span> <span class=n>count</span><span class=p>)</span>

  <span class=kd>defp</span> <span class=n>do_split</span><span class=p>({</span><span class=n>left</span><span class=p>,</span> <span class=p>[</span><span class=n>head</span> <span class=o>|</span> <span class=n>tail</span><span class=p>]},</span> <span class=n>count</span><span class=p>)</span> <span class=ow>when</span> <span class=mi>0</span> <span class=o>&lt;</span> <span class=n>count</span><span class=p>,</span>
    <span class=ss>do</span><span class=p>:</span> <span class=n>do_split</span><span class=p>({[</span><span class=n>head</span> <span class=o>|</span> <span class=n>left</span><span class=p>],</span> <span class=n>tail</span><span class=p>},</span> <span class=n>count</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>

  <span class=kd>defp</span> <span class=n>do_split</span><span class=p>({</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>},</span> <span class=mi>0</span><span class=p>),</span> <span class=ss>do</span><span class=p>:</span> <span class=p>{</span><span class=n>reverse</span><span class=p>(</span><span class=n>left</span><span class=p>),</span> <span class=n>right</span><span class=p>}</span>

  <span class=kd>defp</span> <span class=n>do_split</span><span class=p>({</span><span class=n>left</span><span class=p>,</span> <span class=p>[]},</span> <span class=n>_count</span><span class=p>),</span> <span class=ss>do</span><span class=p>:</span> <span class=p>{</span><span class=n>reverse</span><span class=p>(</span><span class=n>left</span><span class=p>),</span> <span class=p>[]}</span>

  <span class=c1># Reverse list helper</span>
  <span class=na>@spec</span> <span class=n>reverse</span><span class=p>(</span><span class=n>list</span><span class=p>())</span> <span class=o>::</span> <span class=n>list</span><span class=p>()</span>
  <span class=kd>def</span> <span class=n>reverse</span><span class=p>(</span><span class=n>list</span><span class=p>),</span> <span class=ss>do</span><span class=p>:</span> <span class=n>do_reverse</span><span class=p>([],</span> <span class=n>list</span><span class=p>)</span>

  <span class=kd>defp</span> <span class=n>do_reverse</span><span class=p>([],</span> <span class=p>[</span><span class=n>head</span> <span class=o>|</span> <span class=n>tail</span><span class=p>]),</span> <span class=ss>do</span><span class=p>:</span> <span class=n>do_reverse</span><span class=p>([</span><span class=n>head</span><span class=p>],</span> <span class=n>tail</span><span class=p>)</span>
  <span class=kd>defp</span> <span class=n>do_reverse</span><span class=p>(</span><span class=n>list</span><span class=p>,</span> <span class=p>[</span><span class=n>head</span> <span class=o>|</span> <span class=n>tail</span><span class=p>]),</span> <span class=ss>do</span><span class=p>:</span> <span class=n>do_reverse</span><span class=p>([</span><span class=n>head</span> <span class=o>|</span> <span class=n>list</span><span class=p>],</span> <span class=n>tail</span><span class=p>)</span>
  <span class=kd>defp</span> <span class=n>do_reverse</span><span class=p>(</span><span class=n>list</span><span class=p>,</span> <span class=p>[]),</span> <span class=ss>do</span><span class=p>:</span> <span class=n>list</span>
<span class=k>end</span>
</code></pre></div><h2 id=conclusion>Conclusion<a href=#conclusion class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2>
<p>Finding the maximum contiguous sum in Elixir is quite simple to do.
Especially after wrapping ones head around the recursion involved.</p>
<p>I think that this is easier to follow than the imperative version as well.</p>
<p>I hope this was useful for anyone looking into algorithms in functional languages!</p>
<p><a href=https://github.com/SamuelWillis/algorithms/blob/main/elixir/lib/divide_and_conquer/max_contiguous_sum.ex>Click for the full
implementation</a>.</p>
<p><a href=https://github.com/SamuelWillis/algorithms/tree/main/notes/divide-and-conquer/maximum-subarray>And here is my full set of Insertion Sort
notes</a>.</p>
</div>
<hr class=post-end>
<footer class=post-info>
<p>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=tag><a href=https://www.samuelwillis.dev/tags/elixir>Elixir</a></span><span class=tag><a href=https://www.samuelwillis.dev/tags/algorithms>Algorithms</a></span><span class=tag><a href=https://www.samuelwillis.dev/tags/divideandconquer>DivideAndConquer</a></span><span class=tag><a href=https://www.samuelwillis.dev/tags/implementation>Implementation</a></span><span class=tag><a href=https://www.samuelwillis.dev/tags/code>Code</a></span><span class=tag><a href=https://www.samuelwillis.dev/tags/maxiumsubarray>MaxiumSubarray</a></span><span class=tag><a href=https://www.samuelwillis.dev/tags/contiguoussum>ContiguousSum</a></span>
</p>
<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>1364 Words</p>
<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>2021-05-21 03:00 +0000</p>
</footer>
</article>
<div class="post-nav thin">
<a class=next-post href=https://www.samuelwillis.dev/posts/heap-sort-part-1/>
<span class=post-nav-label><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"/><polyline points="12 19 5 12 12 5"/></svg>&nbsp;Newer</span><br><span>Heap Sort, Part 1</span>
</a>
<a class=prev-post href=https://www.samuelwillis.dev/posts/insertion-sort-in-elixir/>
<span class=post-nav-label>Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></svg></span><br><span>Insertion Sort in Elixir</span>
</a>
</div>
<div id=comments class=thin>
</div>
</main>
<footer id=site-footer class="section-inner thin animated fadeIn faster">
<p>&copy; 2021 <a href=https://www.samuelwillis.dev>Samuel Willis</a></p>
<p>
Made with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> &#183; Theme <a href=https://github.com/Track3/hermit target=_blank rel=noopener>Hermit</a> &#183; <a href=https://www.samuelwillis.dev/posts/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a>
</p>
</footer>
<script src=https://www.samuelwillis.dev/js/bundle.min.7d8545daa55d62427355498dd8da13f98ff79a7938ce7d2a5e2ae1ec0de3beb8.js integrity="sha256-fYVF2qVdYkJzVUmN2NoT+Y/3mnk4zn0qXirh7A3jvrg=" crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-194304466-1','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
</body>
</html>