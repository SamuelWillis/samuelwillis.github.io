<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><meta itemprop=name content="Insertion Sort in Elixir"><meta itemprop=description content="Departing from Data Structures such as Queues and Stacks this post will cover the insertion sort algorithm in Elixir.
Insertion sort is one of the first sorting algorithms introduced in Computer Science as its quite simple.
Insertion sort is quite efficient on small data sets and it does the sort in place. Meaning it has O(1) (constant) memory space requirements. Unfortunately, this does not hold true in Elixir as recursion is used causing the space-complexity to be O(n) (linear)."><meta itemprop=datePublished content="2021-04-25T10:00:00-06:00"><meta itemprop=dateModified content="2021-04-24T12:59:20-06:00"><meta itemprop=wordCount content="754"><meta itemprop=keywords content="Elixir,Algorithms,Implementation,Code,Sorting,InsertionSort,"><meta property="og:title" content="Insertion Sort in Elixir"><meta property="og:description" content="Departing from Data Structures such as Queues and Stacks this post will cover the insertion sort algorithm in Elixir.
Insertion sort is one of the first sorting algorithms introduced in Computer Science as its quite simple.
Insertion sort is quite efficient on small data sets and it does the sort in place. Meaning it has O(1) (constant) memory space requirements. Unfortunately, this does not hold true in Elixir as recursion is used causing the space-complexity to be O(n) (linear)."><meta property="og:type" content="article"><meta property="og:url" content="https://www.samuelwillis.dev/posts/insertion-sort-in-elixir/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-25T10:00:00-06:00"><meta property="article:modified_time" content="2021-04-24T12:59:20-06:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Insertion Sort in Elixir"><meta name=twitter:description content="Departing from Data Structures such as Queues and Stacks this post will cover the insertion sort algorithm in Elixir.
Insertion sort is one of the first sorting algorithms introduced in Computer Science as its quite simple.
Insertion sort is quite efficient on small data sets and it does the sort in place. Meaning it has O(1) (constant) memory space requirements. Unfortunately, this does not hold true in Elixir as recursion is used causing the space-complexity to be O(n) (linear)."><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color><link rel="shortcut icon" href=/favicon.ico><title>Insertion Sort in Elixir</title><link rel=stylesheet href=https://www.samuelwillis.dev/css/style.min.f74778e3020c87c304fb5982e09b92ba63a5c7f202996d4c7283d6057acfe9c1.css integrity="sha256-90d44wIMh8ME+1mC4JuSumOlx/ICmW1McoPWBXrP6cE=" crossorigin=anonymous></head><body id=page><header id=site-header class="animated slideInUp"><div class="hdr-wrapper section-inner"><div class=hdr-left><div class=site-branding><a href=https://www.samuelwillis.dev>samuel willis</a></div><nav class="site-nav hide-in-mobile"><a href=https://www.samuelwillis.dev/about/>about</a>
<a href=https://www.samuelwillis.dev/posts/>posts</a></nav></div><div class="hdr-right hdr-icons"><span class="hdr-social hide-in-mobile"><a href=mailto:samuel.w.h.willis@gmail.com target=_blank rel="noopener me" title=Email><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a><a href=https://github.com/SamuelWillis target=_blank rel="noopener me" title=Github><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://www.linkedin.com/in/willissamuel/ target=_blank rel="noopener me" title=Linkedin><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></span><button id=menu-btn class=hdr-btn title=Menu><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button></div></div></header><div id=mobile-menu class="animated fast"><ul><li><a href=https://www.samuelwillis.dev/about/>about</a></li><li><a href=https://www.samuelwillis.dev/posts/>posts</a></li></ul></div><main class="site-main section-inner animated fadeIn faster"><article class=thin><header class=post-header><div class=post-meta><span>Apr 24, 2021</span></div><h1>Insertion Sort in Elixir</h1></header><div class=content><p>Departing from Data Structures such as <a href=https://www.samuelwillis.dev/posts/queues-in-elixir/>Queues</a>
and <a href=https://www.samuelwillis.dev/posts/stacks-in-elixir/>Stacks</a> this post will cover the insertion
sort algorithm in Elixir.</p><p>Insertion sort is one of the first sorting algorithms introduced in Computer
Science as its quite simple.</p><p>Insertion sort is quite efficient on small data sets and it does the sort in
place.
Meaning it has <code>O(1)</code> (constant) memory space requirements.
Unfortunately, this does not hold true in Elixir as recursion is used causing
the space-complexity to be <code>O(n)</code> (linear).</p><h2 id=method>Method<a href=#method class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>In insertion sort, the array into is split into two &ldquo;piles&rdquo;.</p><p>On the left pile are the sorted elements and on the right pile are the unsorted.</p><p>For each element on the right (unsorted), we compare it to elements in the left
(sorted) pile until the element from the right pile is in its sorted position in
the array.</p><p>If the left hand element is larger than the right hand element, we move the left
hand element to the &ldquo;right&rdquo; one position and repeat.</p><p>If the left hand element is less than or equal to the right hand element, we
place the right hand element into the position to the &ldquo;right&rdquo; of the current
left hand position.</p><h2 id=code>Code<a href=#code class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>In imperative languages, insertion sort is most commonly implemented using for
loops and while loops.</p><p>Elixir does not have loops, which can be a little tricky to navigate when you
first start learning Elixir.</p><p>Instead of loops, Elixir provides pattern matching and recursion.</p><p>Placing the insertion sort implementation into a module, the setup will be as
follows:</p><div class=highlight><pre class=chroma><code class=language-elixir data-lang=elixir><span class=kd>defmodule</span> <span class=nc>ElixirImpl.Sorting.InsertionSort</span> <span class=k>do</span>
  <span class=na>@moduledoc</span> <span class=sh>&#34;&#34;&#34;
</span><span class=sh>  Simple insertion sort implementation
</span><span class=sh>  &#34;&#34;&#34;</span>

  <span class=na>@doc</span> <span class=sh>&#34;&#34;&#34;
</span><span class=sh>  Sort the provided list
</span><span class=sh>
</span><span class=sh>  </span><span class=err>##</span><span class=sh> Examples
</span><span class=sh>
</span><span class=sh>    iex&gt; InsertionSort.sort([])
</span><span class=sh>    []
</span><span class=sh>
</span><span class=sh>    iex&gt; InsertionSort.sort([1])
</span><span class=sh>    [1]
</span><span class=sh>
</span><span class=sh>    iex&gt; InsertionSort.sort([1, 0])
</span><span class=sh>    [0, 1]
</span><span class=sh>
</span><span class=sh>    iex&gt; InsertionSort.sort([1, -1, 0])
</span><span class=sh>    [-1, 0, 1]
</span><span class=sh>  &#34;&#34;&#34;</span>
  <span class=na>@spec</span> <span class=n>sort</span><span class=p>(</span><span class=n>list</span><span class=p>())</span> <span class=o>::</span> <span class=n>list</span><span class=p>()</span>
  <span class=kd>def</span> <span class=n>sort</span><span class=p>([]),</span> <span class=ss>do</span><span class=p>:</span> <span class=p>[]</span>
  <span class=kd>def</span> <span class=n>sort</span><span class=p>([</span><span class=n>first</span><span class=p>]),</span> <span class=ss>do</span><span class=p>:</span> <span class=p>[</span><span class=n>first</span><span class=p>]</span>
  <span class=kd>def</span> <span class=n>sort</span><span class=p>([</span><span class=n>first</span> <span class=o>|</span> <span class=n>rest</span><span class=p>]),</span> <span class=ss>do</span><span class=p>:</span> <span class=n>do_sort</span><span class=p>([</span><span class=n>first</span><span class=p>],</span> <span class=n>rest</span><span class=p>)</span>
<span class=k>end</span>
</code></pre></div><p>Note: only Lists were supported in this implementation for simplicity.</p><p>The main sorting logic will come in the form of two private recursive functions.</p><p>The first, <code>do_sort/2</code> will handle looping over each element of the array and
placing it into the correct position amongst the sorted elements.</p><p>To do this an accumulator will be used to store the elements in sorted position.</p><p><code>do_sort/2</code> accepts the sorted elements as its first parameter and the remaining
unsorted elements as its second parameter.</p><p>It will consist of 2 clauses.</p><div class=highlight><pre class=chroma><code class=language-elixir data-lang=elixir>  <span class=kd>defp</span> <span class=n>do_sort</span><span class=p>(</span><span class=n>sorted</span><span class=p>,</span> <span class=n>_unsorted</span> <span class=o>=</span> <span class=p>[</span><span class=n>head</span> <span class=o>|</span> <span class=n>tail</span><span class=p>]),</span> <span class=ss>do</span><span class=p>:</span> <span class=n>do_sort</span><span class=p>(</span><span class=n>insert</span><span class=p>(</span><span class=n>head</span><span class=p>,</span> <span class=n>sorted</span><span class=p>),</span> <span class=n>tail</span><span class=p>)</span>
  <span class=kd>defp</span> <span class=n>do_sort</span><span class=p>(</span><span class=n>sorted</span><span class=p>,</span> <span class=p>[]),</span> <span class=ss>do</span><span class=p>:</span> <span class=n>sorted</span>
</code></pre></div><p>The second private function is <code>insert/2</code>.
It takes care of looping through the sorted list and placing an element in the
correct position.</p><div class=highlight><pre class=chroma><code class=language-elixir data-lang=elixir>  <span class=c1># if no elements to compare against in sorted list, return element as a list</span>
  <span class=kd>defp</span> <span class=n>insert</span><span class=p>(</span><span class=n>element</span><span class=p>,</span> <span class=n>_sorted</span> <span class=o>=</span> <span class=p>[]),</span> <span class=ss>do</span><span class=p>:</span> <span class=p>[</span><span class=n>element</span><span class=p>]</span>
  <span class=c1># if element is less than the first element of the sorted list, insert at front</span>
  <span class=kd>defp</span> <span class=n>insert</span><span class=p>(</span><span class=n>element</span><span class=p>,</span> <span class=p>[</span><span class=n>min</span> <span class=o>|</span> <span class=n>_rest</span><span class=p>]</span> <span class=o>=</span> <span class=n>sorted</span><span class=p>)</span> <span class=ow>when</span> <span class=n>element</span> <span class=o>&lt;=</span> <span class=n>min</span><span class=p>,</span> <span class=ss>do</span><span class=p>:</span> <span class=p>[</span><span class=n>element</span> <span class=o>|</span> <span class=n>sorted</span><span class=p>]</span>
  <span class=c1># Otherwise element is larger than min and we check it against the next sorted element</span>
  <span class=kd>defp</span> <span class=n>insert</span><span class=p>(</span><span class=n>element</span><span class=p>,</span> <span class=p>[</span><span class=n>min</span> <span class=o>|</span> <span class=n>rest</span><span class=p>]),</span> <span class=ss>do</span><span class=p>:</span> <span class=p>[</span><span class=n>min</span> <span class=o>|</span> <span class=n>insert</span><span class=p>(</span><span class=n>element</span><span class=p>,</span> <span class=n>rest</span><span class=p>)]</span>
</code></pre></div><p>Putting it all together the implementation is:</p><div class=highlight><pre class=chroma><code class=language-elixir data-lang=elixir><span class=kd>defmodule</span> <span class=nc>ElixirImpl.Sorting.InsertionSort</span> <span class=k>do</span>
  <span class=na>@moduledoc</span> <span class=sh>&#34;&#34;&#34;
</span><span class=sh>  Simple insertion sort implementation
</span><span class=sh>  &#34;&#34;&#34;</span>

  <span class=na>@doc</span> <span class=sh>&#34;&#34;&#34;
</span><span class=sh>  Sort the provided list
</span><span class=sh>
</span><span class=sh>  </span><span class=err>##</span><span class=sh> Examples
</span><span class=sh>
</span><span class=sh>    iex&gt; InsertionSort.sort([])
</span><span class=sh>    []
</span><span class=sh>
</span><span class=sh>    iex&gt; InsertionSort.sort([1])
</span><span class=sh>    [1]
</span><span class=sh>
</span><span class=sh>    iex&gt; InsertionSort.sort([1, 0])
</span><span class=sh>    [0, 1]
</span><span class=sh>
</span><span class=sh>    iex&gt; InsertionSort.sort([1, -1, 0])
</span><span class=sh>    [-1, 0, 1]
</span><span class=sh>  &#34;&#34;&#34;</span>
  <span class=na>@spec</span> <span class=n>sort</span><span class=p>(</span><span class=n>list</span><span class=p>())</span> <span class=o>::</span> <span class=n>list</span><span class=p>()</span>
  <span class=kd>def</span> <span class=n>sort</span><span class=p>([]),</span> <span class=ss>do</span><span class=p>:</span> <span class=p>[]</span>
  <span class=kd>def</span> <span class=n>sort</span><span class=p>([</span><span class=n>first</span><span class=p>]),</span> <span class=ss>do</span><span class=p>:</span> <span class=p>[</span><span class=n>first</span><span class=p>]</span>
  <span class=kd>def</span> <span class=n>sort</span><span class=p>([</span><span class=n>first</span> <span class=o>|</span> <span class=n>rest</span><span class=p>]),</span> <span class=ss>do</span><span class=p>:</span> <span class=n>do_sort</span><span class=p>([</span><span class=n>first</span><span class=p>],</span> <span class=n>rest</span><span class=p>)</span>

  <span class=kd>defp</span> <span class=n>do_sort</span><span class=p>(</span><span class=n>sorted</span><span class=p>,</span> <span class=n>_unsorted</span> <span class=o>=</span> <span class=p>[</span><span class=n>head</span> <span class=o>|</span> <span class=n>tail</span><span class=p>]),</span>
    <span class=ss>do</span><span class=p>:</span> <span class=n>do_sort</span><span class=p>(</span><span class=n>insert</span><span class=p>(</span><span class=n>head</span><span class=p>,</span> <span class=n>sorted</span><span class=p>),</span> <span class=n>tail</span><span class=p>)</span>
  <span class=kd>defp</span> <span class=n>do_sort</span><span class=p>(</span><span class=n>sorted</span><span class=p>,</span> <span class=p>[]),</span>
    <span class=ss>do</span><span class=p>:</span> <span class=n>sorted</span>

  <span class=c1># if no elements to compare against in sorted, return element as a list</span>
  <span class=kd>defp</span> <span class=n>insert</span><span class=p>(</span><span class=n>element</span><span class=p>,</span> <span class=n>_sorted</span> <span class=o>=</span> <span class=p>[]),</span>
    <span class=ss>do</span><span class=p>:</span> <span class=p>[</span><span class=n>element</span><span class=p>]</span>
  <span class=c1># if element is less than the first element of the sorted list, insert at front</span>
  <span class=kd>defp</span> <span class=n>insert</span><span class=p>(</span><span class=n>element</span><span class=p>,</span> <span class=p>[</span><span class=n>min</span> <span class=o>|</span> <span class=n>_rest</span><span class=p>]</span> <span class=o>=</span> <span class=n>sorted</span><span class=p>)</span> <span class=ow>when</span> <span class=n>element</span> <span class=o>&lt;=</span> <span class=n>min</span><span class=p>,</span>
    <span class=ss>do</span><span class=p>:</span> <span class=p>[</span><span class=n>element</span> <span class=o>|</span> <span class=n>sorted</span><span class=p>]</span>
  <span class=c1># Otherwise try insert element into remainder of sorted list</span>
  <span class=kd>defp</span> <span class=n>insert</span><span class=p>(</span><span class=n>element</span><span class=p>,</span> <span class=p>[</span><span class=n>min</span> <span class=o>|</span> <span class=n>rest</span><span class=p>]),</span>
    <span class=ss>do</span><span class=p>:</span> <span class=p>[</span><span class=n>min</span> <span class=o>|</span> <span class=n>insert</span><span class=p>(</span><span class=n>element</span><span class=p>,</span> <span class=n>rest</span><span class=p>)]</span>
<span class=k>end</span>
</code></pre></div><h2 id=conclusion>Conclusion<a href=#conclusion class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>Insertion sort is a simple sorting algorithm and implementing it in Elixir was a
great way to get familiar with <a href=https://en.wikipedia.org/wiki/Recursion_(computer_science)>recursion</a>
and <a href=https://en.wikipedia.org/wiki/Tail_call>tail-call recursion</a>.
It was also a great exercise to increase comfort with pattern matches and
looping lists.</p><p>This implementation did lose the <code>O(1)</code> space complexity of an imperative
implementation, but that loss holds true for most recursive implementations as
space is needed on the stack for all the function calls.</p><p><a href=https://github.com/SamuelWillis/algorithms/blob/main/elixir/lib/sorting/insertion_sort.ex>Click for the full
implementation</a>.</p><p><a href=https://github.com/SamuelWillis/algorithms/tree/main/notes/sorting/insertion-sort>And here is my full set of Insertion Sort
notes</a>.</p></div><hr class=post-end><footer class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=tag><a href=https://www.samuelwillis.dev/tags/elixir>Elixir</a></span><span class=tag><a href=https://www.samuelwillis.dev/tags/algorithms>Algorithms</a></span><span class=tag><a href=https://www.samuelwillis.dev/tags/implementation>Implementation</a></span><span class=tag><a href=https://www.samuelwillis.dev/tags/code>Code</a></span><span class=tag><a href=https://www.samuelwillis.dev/tags/sorting>Sorting</a></span><span class=tag><a href=https://www.samuelwillis.dev/tags/insertionsort>InsertionSort</a></span></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>754 Words</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>2021-04-24 18:59 +0000</p></footer></article><div class="post-nav thin"><a class=next-post href=https://www.samuelwillis.dev/posts/max-contiguous-sum-in-elixir/><span class=post-nav-label><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"/><polyline points="12 19 5 12 12 5"/></svg>&nbsp;Newer</span><br><span>Max Subarray in Elixir</span></a>
<a class=prev-post href=https://www.samuelwillis.dev/posts/queues-in-elixir/><span class=post-nav-label>Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></svg></span><br><span>Queues in Elixir</span></a></div><div id=comments class=thin></div></main><footer id=site-footer class="section-inner thin animated fadeIn faster"><p>&copy; 2021 <a href=https://www.samuelwillis.dev>Samuel Willis</a></p><p>Made with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> &#183; Theme <a href=https://github.com/Track3/hermit target=_blank rel=noopener>Hermit</a> &#183; <a href=https://www.samuelwillis.dev/posts/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></p></footer><script src=https://www.samuelwillis.dev/js/bundle.min.7d8545daa55d62427355498dd8da13f98ff79a7938ce7d2a5e2ae1ec0de3beb8.js integrity="sha256-fYVF2qVdYkJzVUmN2NoT+Y/3mnk4zn0qXirh7A3jvrg=" crossorigin=anonymous></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-194304466-1','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>